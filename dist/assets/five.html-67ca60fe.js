const e=JSON.parse('{"key":"v-20e05b80","path":"/bookList/Zosan%20algorithm/five.html","title":"排序总结与数据结构","lang":"zh-CN","frontmatter":{"title":"排序总结与数据结构","icon":"fab fa-markdown","order":5,"category":["排序","数据结构"],"tag":["排序","数据结构"],"next":"six.md","prev":"four.md"},"headers":[{"level":2,"title":"排序总结","slug":"排序总结","link":"#排序总结","children":[]},{"level":2,"title":"堆结构","slug":"堆结构","link":"#堆结构","children":[]},{"level":2,"title":"有序表","slug":"有序表","link":"#有序表","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":2.04,"words":611},"filePathRelative":"bookList/Zosan algorithm/five.md","excerpt":"<h2> 排序总结</h2>\\n<p>系统中的排序，如果是基础类型的排序会用快排，</p>\\n<p>非基础类型的排序，会用归并。</p>\\n<p>因为非基础类型需要用到稳定性。</p>\\n<p>目前没有O(NlogN)，空间复杂度为O(1)的排序算法，并且稳定的。</p>\\n<ul>\\n<li><strong>稳定性：</strong></li>\\n</ul>\\n<p>用于第一次排序之后，还可以使用第二次不同类型的排序来区别并且第一个排序的顺序不会被打乱。</p>\\n<p>如一个数据结构有班级和身高两个特征。</p>\\n<p>第一轮排序不稳定，按身高排。</p>\\n<p>第二轮排序稳定，按班级排排。</p>\\n<p>得到的就是一个班级内身高按顺序排，并且班级也按顺序排的结果。</p>"}');export{e as data};
