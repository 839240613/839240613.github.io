import{_ as p}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as a,e as o}from"./app-82a511c8.js";const r={},t=o('<h2 id="排序总结" tabindex="-1"><a class="header-anchor" href="#排序总结" aria-hidden="true">#</a> 排序总结</h2><p>系统中的排序，如果是基础类型的排序会用快排，</p><p>非基础类型的排序，会用归并。</p><p>因为非基础类型需要用到稳定性。</p><p>目前没有O(NlogN)，空间复杂度为O(1)的排序算法，并且稳定的。</p><ul><li><strong>稳定性：</strong></li></ul><p>用于第一次排序之后，还可以使用第二次不同类型的排序来区别并且第一个排序的顺序不会被打乱。</p><p>如一个数据结构有班级和身高两个特征。</p><p>第一轮排序不稳定，按身高排。</p><p>第二轮排序稳定，按班级排排。</p><p>得到的就是一个班级内身高按顺序排，并且班级也按顺序排的结果。</p><ul><li>小总结：</li></ul><p>插入排序在数据量小的情况下，效率很高，但是数据量大的时候，不及快排，</p><p>因为它的插入排序的常数时间很小。</p><p>快排在数据量大的时候，速度就比较好了，但是没有稳定性，空间复杂度为O(logN)，都能够接受。</p><p>归并排序具有稳定性，并且时间复杂度为O(NlogN)，但是空间复杂度为O(N)，</p><p>意味着需要用挺大的一笔内存消耗来换取稳定性和时间。</p><p>在内存资源紧张的情况下，最好的办法就是用堆排序了，</p><p>虽然不稳，但是速度在数据量大的情况下还是比插入排序快一些。</p><ul><li>比较器</li></ul><p>又叫仿函数，也叫重载运算符。</p><p>返回为0的时候不做交换。</p><p>返回为正数的时候，第二个参数在前面，</p><p>返回为负数的时候，第一个参数在前面。</p><h2 id="堆结构" tabindex="-1"><a class="header-anchor" href="#堆结构" aria-hidden="true">#</a> 堆结构</h2><p>系统的堆结构只有两个接口，</p><p>一个是 <code>make_heap</code>，</p><p>一个是 <code>pop_heap</code>。</p><p>一进一出。</p><p>如果在中途的地方，改变值，</p><p>系统堆只能从头往下开始重新排序，</p><p>代价比较高，但是手动写的堆结构，可以从中间进行较小代价的调整。</p><h2 id="有序表" tabindex="-1"><a class="header-anchor" href="#有序表" aria-hidden="true">#</a> 有序表</h2><p>增删改查都是O(logN)，不是基础类型则需要用比较器告诉计算机如果排序。</p><p><strong>例子：</strong></p><p>红黑树，AL树，size-banlance-tree，跳表</p><p>有序表的常数项比哈希表的常数项略大。</p>',37),i=[t];function l(c,n){return e(),a("div",null,i)}const s=p(r,[["render",l],["__file","five.html.vue"]]);export{s as default};
