const l=JSON.parse('{"key":"v-d9d14e84","path":"/storehouse/Programming%20quote.html","title":"","lang":"zh-CN","frontmatter":{},"headers":[],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":2.57,"words":770},"filePathRelative":"storehouse/Programming quote.md","excerpt":"<ul>\\n<li>\\n<ol>\\n<li>while 和 if这些条件判断就是条件判断，没有知行的功效，要记得执行，移动。</li>\\n</ol>\\n</li>\\n<li>\\n<ol start=\\"2\\">\\n<li>根据本来的顺序来判断大小，可能会没有这么绕弯。</li>\\n</ol>\\n</li>\\n<li>\\n<ol start=\\"3\\">\\n<li>大减小才是你想要的，R-L才是你的数组长度。</li>\\n</ol>\\n</li>\\n<li>\\n<ol start=\\"4\\">\\n<li>三目运算符判断是可以添加很多的&amp;&amp;来限制条件，判断后只能够运算一次，并且不能够上函数，使用的时候注意是否判断之后还需要进行下一步分别的操作。\\n用好这个东西代码的简洁度蹭蹭上涨。</li>\\n</ol>\\n</li>\\n<li>\\n<ol start=\\"5\\">\\n<li>if()为空才执行是需要写的。空写。</li>\\n</ol>\\n</li>\\n<li>\\n<ol start=\\"6\\">\\n<li>快排中的标准值也可能会在原位的。</li>\\n</ol>\\n</li>\\n<li>\\n<ol start=\\"7\\">\\n<li>特别是递归的边界条件需要重视。所有的进入条件都需要验证一下。</li>\\n</ol>\\n</li>\\n<li>\\n<ol start=\\"8\\">\\n<li>用for还是while要先问一下自己。</li>\\n</ol>\\n</li>\\n<li>\\n<ol start=\\"9\\">\\n<li>在数组操作中，Index是个非常的东西，可以找到位置，又可以取得内容。</li>\\n</ol>\\n</li>\\n<li>\\n<ol start=\\"10\\">\\n<li>桶的大小是最大值+1。所以创建的时候，是max+1.倒回去的时候也是max+1。</li>\\n</ol>\\n</li>\\n<li>\\n<ol start=\\"11\\">\\n<li>使用的数组，循环回来查看是否需要清空。</li>\\n</ol>\\n</li>\\n<li>\\n<ol start=\\"12\\">\\n<li>在条件判断中先做的事情，可能会因为后做的事情，变成，先做的事情多做一次，后做的事情少做最后一次。\\n有一个这样的模型帮助你判断循环：</li>\\n</ol>\\n</li>\\n</ul>"}');export{l as data};
