import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as i,c as a,e as n}from"./app-e4bb05b4.js";const t="/assets/images/邻接表.png",l="/assets/images/K算法1.png",r="/assets/images/K算法2.png",s="/assets/images/K算法3.png",g="/assets/images/并查集K算法.png",d="/assets/images/并查K算法222.png",p="/assets/images/并查集K算法3.png",c="/assets/images/p算法1.png",o="/assets/images/p算法2.png",h="/assets/images/p算法3.png",f="/assets/images/p算法4.png",u={},x=n('<h2 id="图的定义" tabindex="-1"><a class="header-anchor" href="#图的定义" aria-hidden="true">#</a> 图的定义</h2><p>图由</p><ul><li><p>一个哈希表 (int,Node) nodes -&gt; 记录点的信息</p><ul><li>其中 Node具有 <ul><li>int in -&gt; 记录入度</li><li>int out -&gt; 记录出度</li><li>int data -&gt; 记录点的数据</li><li>ArrayList(Node) -&gt; 记录散发的边涉及的点</li><li>ArrayList(Edge） -&gt; 记录散发的边</li></ul></li></ul></li><li><p>一个哈希表 (Edge) edges -&gt; 记录边的信息</p><ul><li>Edge 具有 <ul><li>int data -&gt; 记录边的数据</li><li>Node from -&gt; 记录边的起点</li><li>Node to -&gt; 记录边的终点</li></ul></li></ul></li></ul><h2 id="图的表达方式" tabindex="-1"><a class="header-anchor" href="#图的表达方式" aria-hidden="true">#</a> 图的表达方式</h2><ul><li><strong>邻接表</strong></li></ul><p>从点的角度，查看图的结构</p><div style="text-align:center;"><figure><img src="'+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>{A:[C,D],</p><p>C:[A,D,4],</p><p>4:[C],</p><p>D:[A,C]}</p><ul><li><strong>邻接矩阵</strong></li></ul><p>从边的角度，查看图的结构</p><div style="text-align:center;"><figure><img src="'+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><table><thead><tr><th style="text-align:center;"></th><th style="text-align:center;">A</th><th style="text-align:center;">C</th><th style="text-align:center;">D</th><th style="text-align:center;">4</th></tr></thead><tbody><tr><td style="text-align:center;">A</td><td style="text-align:center;">0</td><td style="text-align:center;">1</td><td style="text-align:center;">1</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">C</td><td style="text-align:center;">1</td><td style="text-align:center;">0</td><td style="text-align:center;">1</td><td style="text-align:center;">1</td></tr><tr><td style="text-align:center;">D</td><td style="text-align:center;">1</td><td style="text-align:center;">1</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">4</td><td style="text-align:center;">0</td><td style="text-align:center;">1</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td></tr></tbody></table><h2 id="层序遍历-宽度遍历" tabindex="-1"><a class="header-anchor" href="#层序遍历-宽度遍历" aria-hidden="true">#</a> 层序遍历（宽度遍历）</h2><p>把结点装进队列，</p><p>每出一个队列打印并记录set，并把所有相关联的放队列，</p><p>记录set的目的是防止重复遍历。</p><ul><li><p>1.利用队列实现。</p></li><li><p>2.从源节点开始依次按照宽度进队列，然后弹出。</p></li><li><p>3.每弹出一个点，把该节点所有没有进过队列的邻接点放入队列。</p></li><li><p>4.直到队列变空</p></li></ul><h2 id="深度遍历" tabindex="-1"><a class="header-anchor" href="#深度遍历" aria-hidden="true">#</a> 深度遍历</h2><p><strong>我只抓一条路走到黑。</strong></p><p>把结点装进栈，</p><p>每出一个栈打印并记录set，随便选取一个相关的节点进栈，这个节点必须不在set中注册过，</p><p><strong>在装选取一个相关节点前，把出栈的节点装回去。</strong></p><ul><li><p>1.利用栈实现。</p></li><li><p>2.从源节点开始依次按照深度进栈，然后弹出。</p></li><li><p>3.每弹出一个点，把该节点没有进过栈的邻接点放入栈。</p></li><li><p>4.直到栈变空</p></li></ul><h2 id="拓补排序" tabindex="-1"><a class="header-anchor" href="#拓补排序" aria-hidden="true">#</a> 拓补排序</h2><p>编译文件之前，先编译什么文件的排序。</p><p><strong>为了让编译文件顺利执行，而不是随意的编译，一直在循环编译，或者前置文件没有准备好的编译。</strong></p><ul><li>不断找一个入度为0的点，然后把这个点删除，并把所有相关的线也删除，这个点就是这次的输出对象。</li></ul><h2 id="图生成树的算法" tabindex="-1"><a class="header-anchor" href="#图生成树的算法" aria-hidden="true">#</a> 图生成树的算法</h2><p>由图生成的树权值是最小的。“路由器寻找最短的路径。”</p><h3 id="kruskal算法" tabindex="-1"><a class="header-anchor" href="#kruskal算法" aria-hidden="true">#</a> kruskal算法</h3><h4 id="动作" tabindex="-1"><a class="header-anchor" href="#动作" aria-hidden="true">#</a> <strong>动作：</strong></h4><div style="text-align:center;"><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>循环寻找最小的边</p><div style="text-align:center;"><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>判断图中结构并没有成环</p><p>继续添加最小的边</p><div style="text-align:center;"><figure><img src="'+s+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>一直从权值最小的边到权值最大的边判断，不成环加上，成环结束。</p><p><strong>主要的问题点就在于如何判断是否成环。</strong></p><p>用并查集的方法寻找</p><p>根据查找的边，来添加并查集，</p><div style="text-align:center;"><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>添加3的时候B加入A，</p><div style="text-align:center;"><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>添加的时候判断是否是同一个集合，</p><div style="text-align:center;"><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>根据并查集快速判断同一个集合的方法，就是不断追溯到源头，查看是否相等</p><p>可以快速的判断是否成环。</p><h3 id="prim算法" tabindex="-1"><a class="header-anchor" href="#prim算法" aria-hidden="true">#</a> prim算法</h3><h4 id="动作-1" tabindex="-1"><a class="header-anchor" href="#动作-1" aria-hidden="true">#</a> <strong>动作：</strong></h4><p>把A放进去然后把A附近的边都记录，</p><div style="text-align:center;"><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>选取最小值的一条边确定为树的边，把最小边对于的节点放进去。</p><p>按照这样的规则多走几步就会变成这样</p><div style="text-align:center;"><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>处于D时，由于结点周围的边全都记录了，因此，选取已经记录的最小值的边，并且该边至少有一端的结点是未解锁的。</p><p>因此选择值为5左边为B的点。</p><div style="text-align:center;"><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>重复上述步骤直到所有的结点都完结。</p><p>最后出现的情况会变成这样。</p><div style="text-align:center;"><figure><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>图中红色的边就是树的边，整个最小二叉树就生成了。</p><p>所有的数据结构用简单的哈希表即可。</p>',66),y=[x];function m(_,b){return i(),a("div",null,y)}const A=e(u,[["render",m],["__file","eight.html.vue"]]);export{A as default};
