import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as n,c as e,e as s}from"./app-e4bb05b4.js";const i={},p=s(`<h2 id="词法陷阱" tabindex="-1"><a class="header-anchor" href="#词法陷阱" aria-hidden="true">#</a> 词法陷阱</h2><h3 id="第一个-就是返回值的错误" tabindex="-1"><a class="header-anchor" href="#第一个-就是返回值的错误" aria-hidden="true">#</a> 第一个 就是返回值的错误</h3><h3 id="第二个-是常见的数组程度和取下标之间的种种问题。" tabindex="-1"><a class="header-anchor" href="#第二个-是常见的数组程度和取下标之间的种种问题。" aria-hidden="true">#</a> 第二个 是常见的数组程度和取下标之间的种种问题。</h3><h3 id="第三个-是-和-号的问题" tabindex="-1"><a class="header-anchor" href="#第三个-是-和-号的问题" aria-hidden="true">#</a> 第三个 是=和==号的问题</h3><p>使用while(a = b) 这样的结构的时候，建议写成while((a=b)!=0)</p><p>这样就非常的nice了</p><h3 id="第四个-词语分析中的贪心法" tabindex="-1"><a class="header-anchor" href="#第四个-词语分析中的贪心法" aria-hidden="true">#</a> 第四个 词语分析中的贪心法</h3><p>语法分析室尽可能的贪婪的，所以，如果一个词法单元可以被两个词法单元构成，那么语法分析器会优先选择有两个词法单元构成的符号。</p><p>比如，这样的代码</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>y <span class="token operator">=</span> x<span class="token comment">/*p;
</span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>会被理解为注释。</p><h3 id="整型常量" tabindex="-1"><a class="header-anchor" href="#整型常量" aria-hidden="true">#</a> 整型常量</h3><p>在写整型数的时候，10和010是完全不一样的东西，有时候就会搞错。</p><p>有时候在一些场合就会导致这样的错误。</p><h3 id="字符串和字符数组的问题" tabindex="-1"><a class="header-anchor" href="#字符串和字符数组的问题" aria-hidden="true">#</a> 字符串和字符数组的问题</h3><p>char * p = &#39;/&#39;;</p><p>是有问题的，因为p是指针，&quot;&quot;也是指针，但是&#39;&#39;却是一个实实在在的char</p><p>因为整数型(一般为16为或者32位)的存储空间可以容纳多个字符串(一般为8位)，因此有的C编译器允许在一个字符常量(以及字符常量)中包括多个字符。</p><p>也就是会出现能用&#39;yes&#39; 代替 &quot;yes&quot; 这在不同的编译器里面会有不同的做法。</p><h3 id="注释嵌套的问题" tabindex="-1"><a class="header-anchor" href="#注释嵌套的问题" aria-hidden="true">#</a> 注释嵌套的问题</h3><p>/<em>/</em>/0*/**/1;</p><p>这个代码在允许注释嵌套的时候会变成 1; 不允许注释嵌套的时候就会变成 0*1；</p><p>主要就是想讲解语法的贪婪性，如果不允许嵌套第一个*/就会被认为是注释的结束符。</p><h3 id="左值不能再运算的问题" tabindex="-1"><a class="header-anchor" href="#左值不能再运算的问题" aria-hidden="true">#</a> 左值不能再运算的问题</h3><p>a+++++b; 左值是运算的</p><p>在上面的式子中，只是++没有找到操作数懵了。</p><p>并且确实左值是不可以作为操作数的。 也就是(a+1) = 2;是不允许的行为。</p><h2 id="语法陷阱" tabindex="-1"><a class="header-anchor" href="#语法陷阱" aria-hidden="true">#</a> 语法陷阱</h2><h3 id="函数声明的问题。" tabindex="-1"><a class="header-anchor" href="#函数声明的问题。" aria-hidden="true">#</a> 函数声明的问题。</h3><p>tepydef简化声明的用法</p><p>char (*(*x(void))[5])(void); 这个申明是非常复杂的</p><p>tepydef char (*Func)(void);</p><p>表示Func是一个返回值为char参数值为void的一个函数指针。</p><p>变成Func(*x(void)[5]);</p><p>再来一个定义别名 tepydef Func Arr[5]; // 表示Func还是一个指针数组。</p><p>就可以写成 Arr* x(void);</p><h3 id="运算符的优先级问题" tabindex="-1"><a class="header-anchor" href="#运算符的优先级问题" aria-hidden="true">#</a> 运算符的优先级问题</h3><p>优先级最高的运算符不是真正意义上的运算符，包括:数组下标、函数调用操作符各结构成员选择操作符。</p><p>需要记住两点，</p><p>1.任何一个逻辑运算符的优先级地域于关系运算符，</p><p>2.以为运算符的优先级比算术运算符要低，但是比关系运算符要高的多</p><ol start="3"><li>赋值运算符的优先级很低很低。</li></ol><h3 id="的问题" tabindex="-1"><a class="header-anchor" href="#的问题" aria-hidden="true">#</a> ;的问题</h3><ol><li><p>如果函数申明不规范，没有返回值，被无意return的值就会返回</p></li><li><p>如果结构体没有;那么很可能让下面的函数返回一个结构体。</p></li></ol><h3 id="swtich" tabindex="-1"><a class="header-anchor" href="#swtich" aria-hidden="true">#</a> swtich</h3><p>swtich(int a) {</p><pre><code>case 1:

	break;

case 2:

	break;

default:

	break;
</code></pre><p>};</p><p>在没有break的地方可以加一个注释。</p><h3 id="else陷阱" tabindex="-1"><a class="header-anchor" href="#else陷阱" aria-hidden="true">#</a> else陷阱</h3><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">else</span>
  a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述else中，else是if(b = 0)的分支，因为else更喜欢贴近的if</p><h2 id="语义陷阱" tabindex="-1"><a class="header-anchor" href="#语义陷阱" aria-hidden="true">#</a> 语义陷阱</h2><h3 id="数组和指针" tabindex="-1"><a class="header-anchor" href="#数组和指针" aria-hidden="true">#</a> 数组和指针</h3><p>C语言的二维数组够你喝很久很久了。</p><p>int (*monthp){31};</p><p>这是一个非常可怕的指针数组，其实monthp的位置是没有限制的。</p><h3 id="非指针数组" tabindex="-1"><a class="header-anchor" href="#非指针数组" aria-hidden="true">#</a> 非指针数组</h3><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">char</span><span class="token operator">*</span> r<span class="token punctuation">;</span>

<span class="token function">strcpy</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是会报错的，因为r并没有实际的地址，r的地址是随机分配到，非常危险。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">char</span><span class="token operator">*</span> r<span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

r <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">strlen</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">strcpy</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述过程有三个错误</p><ul><li><ol><li>分配的内存空间是不够大的</li></ol></li><li><ol start="2"><li>没有释放内存。</li></ol></li><li><ol start="3"><li>没有检查内存是否分配成功</li></ol></li></ul><p>这些错误都是致命的。</p><h3 id="避免举耦法" tabindex="-1"><a class="header-anchor" href="#避免举耦法" aria-hidden="true">#</a> 避免举耦法</h3><p>深拷贝和浅拷贝的问题，复制指针，指针所指向的内容是不会被复制的。</p><h3 id="数组的范围问题" tabindex="-1"><a class="header-anchor" href="#数组的范围问题" aria-hidden="true">#</a> 数组的范围问题</h3><p>边界问题用，[)来表示，下边界是取的，上边界是不取的，上下一减就是里面包含的数了。</p><p>也就是第一个入界点和第一个出界点来计算。</p><p>C语言就是不对称边界使用的语言。</p><p>注意到了 --n会比n--快一点。</p><h3 id="的问题-1" tabindex="-1"><a class="header-anchor" href="#的问题-1" aria-hidden="true">#</a> ++的问题</h3><p>x[i] = y[i++];</p><p>这样的东西是不对的，因为你无法保证，i++是否是运行之前。</p><h3 id="和" tabindex="-1"><a class="header-anchor" href="#和" aria-hidden="true">#</a> &amp;&amp;和&amp;</h3><p>&amp;和&amp;&amp;相比，&amp;是会读取值的。</p><h2 id="连接" tabindex="-1"><a class="header-anchor" href="#连接" aria-hidden="true">#</a> 连接</h2><p>变量存储地方等等的问题。</p><p>extern int x;</p><p>这个东西就是x的什么并不是定义而是声明，连接器就会找这个x的位置，而不是重新分配内存。</p><h3 id="讲了很多就是变量名称和static的妙用" tabindex="-1"><a class="header-anchor" href="#讲了很多就是变量名称和static的妙用" aria-hidden="true">#</a> 讲了很多就是变量名称和static的妙用</h3><h3 id="牛逼puls的错误" tabindex="-1"><a class="header-anchor" href="#牛逼puls的错误" aria-hidden="true">#</a> 牛逼puls的错误</h3><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> i<span class="token punctuation">;</span>
<span class="token keyword">char</span> c<span class="token punctuation">;</span>

<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出会是这样 0 0 0 0 0 0 1 2 4 5</p><p>scanf在不断的刷新i的低位数据。这个行为是栈的存储空间是从高到低而决定的。</p><h3 id="申明的问题" tabindex="-1"><a class="header-anchor" href="#申明的问题" aria-hidden="true">#</a> 申明的问题</h3><p>extern char *和extern char []始终是不一样的东西。</p><h3 id="函数申明" tabindex="-1"><a class="header-anchor" href="#函数申明" aria-hidden="true">#</a> 函数申明</h3><p>C语言的规则中，如果一个未声明的标识符后跟着一个开括号，那么这个未声明的标识符是一个函数，并且返回一个整数类型。</p><h3 id="之前就困惑你的extern" tabindex="-1"><a class="header-anchor" href="#之前就困惑你的extern" aria-hidden="true">#</a> 之前就困惑你的extern</h3><p>在.h上声明 extern 就可以不用在所有的地方extern，预编译就会帮助每个文件都申明</p><p>在相应的.c文件上定义，</p><p>在main文件上只需要在预编译的时候知道有这样的东西就可以了，之后的连接就会做出一系列的操作。</p><h2 id="一些常常出错误的库函数" tabindex="-1"><a class="header-anchor" href="#一些常常出错误的库函数" aria-hidden="true">#</a> 一些常常出错误的库函数</h2><h3 id="getchar" tabindex="-1"><a class="header-anchor" href="#getchar" aria-hidden="true">#</a> getchar()</h3><p>这个函数的返回类型是int 因此，因此会出现一些错误。</p><h3 id="文件的一个输入操作不能够紧跟下一个输出操作" tabindex="-1"><a class="header-anchor" href="#文件的一个输入操作不能够紧跟下一个输出操作" aria-hidden="true">#</a> 文件的一个输入操作不能够紧跟下一个输出操作</h3><p>还有很多很多你看不懂的</p><h2 id="预处理器" tabindex="-1"><a class="header-anchor" href="#预处理器" aria-hidden="true">#</a> 预处理器</h2><h3 id="不能忽视宏定义中的空格" tabindex="-1"><a class="header-anchor" href="#不能忽视宏定义中的空格" aria-hidden="true">#</a> 不能忽视宏定义中的空格</h3><p>#define f(x) （（x）-1）</p><p>在调用的时候可以 f (x)</p><p>但是定义的时候，#define f (x) ((x)-1)</p><p>会把f替换为(x)((x)-1)这是非常可怕的。</p><h3 id="宏和函数的差别是非常大的。参数是无脑替换的。" tabindex="-1"><a class="header-anchor" href="#宏和函数的差别是非常大的。参数是无脑替换的。" aria-hidden="true">#</a> 宏和函数的差别是非常大的。参数是无脑替换的。</h3><p>在宏运算中加入自增自减会出现可怕的副作用。</p><h3 id="宏不是语句" tabindex="-1"><a class="header-anchor" href="#宏不是语句" aria-hidden="true">#</a> 宏不是语句</h3><p>在if和else中，夹杂宏可能会出现问题</p><h3 id="宏也不是定义类型" tabindex="-1"><a class="header-anchor" href="#宏也不是定义类型" aria-hidden="true">#</a> 宏也不是定义类型</h3><p>在宏换别名的时候，会出现意向不到的情况</p><p>#define T1 struct foo*</p><p>T1 a,b</p><p>这样的类型定义就是有问题的，a会变成指针，而b不会</p><h2 id="可移值性问题" tabindex="-1"><a class="header-anchor" href="#可移值性问题" aria-hidden="true">#</a> 可移值性问题</h2><h3 id="新标准" tabindex="-1"><a class="header-anchor" href="#新标准" aria-hidden="true">#</a> 新标准</h3><p>是否需要对新标准进行的一定的改进</p><h3 id="标志符名称的限制" tabindex="-1"><a class="header-anchor" href="#标志符名称的限制" aria-hidden="true">#</a> 标志符名称的限制</h3><p>ANSI C语言规定的是，外部标识符前六个字符是能够区分的，并且很可能不区分大小写。</p><p>在不同环境中，会有这样的情况。</p><h3 id="整数的大小" tabindex="-1"><a class="header-anchor" href="#整数的大小" aria-hidden="true">#</a> 整数的大小</h3><p>在移值的时候，最好就是typedef定义一些东西，以便在其他地方更好的改变。</p><h3 id="字符是有符号整数还是无符号整数" tabindex="-1"><a class="header-anchor" href="#字符是有符号整数还是无符号整数" aria-hidden="true">#</a> 字符是有符号整数还是无符号整数</h3><p>这是一个类型转化的问题 char类型转化为int的时候因为正负号的问题，会考虑补充的位数</p><p>因此定义的时候最好都是用unsigned char来定义字符串就是最好的了。</p><p>另外还有一个问题就是，char转变为unsigned int是先转变为int的，因为也会出现上面的问题。</p><h3 id="移位运算" tabindex="-1"><a class="header-anchor" href="#移位运算" aria-hidden="true">#</a> 移位运算</h3><ul><li><ol><li>在向右移位时，空出来的位填充什么，用无符号类型就必然填充0。</li></ol></li><li><ol start="2"><li>移位运算的计数是严格小于n位的也就是32位的数字，最多移位31位</li></ol></li><li><ol start="3"><li>并且如果是正数&gt;&gt;这样的移位运算比/2快，但是如果是负数这样的运算就是错误的。</li></ol></li></ul><h3 id="除法运算时发生截断" tabindex="-1"><a class="header-anchor" href="#除法运算时发生截断" aria-hidden="true">#</a> 除法运算时发生截断</h3><p>没有看懂</p><h3 id="随机数的大小" tabindex="-1"><a class="header-anchor" href="#随机数的大小" aria-hidden="true">#</a> 随机数的大小</h3><p>rand()返回的随机数范围是不一样的</p><p>ANSI C标准中定义了一个常数RAND_MAX这个就是随机数的最大数值</p><h3 id="大小写转换和宏" tabindex="-1"><a class="header-anchor" href="#大小写转换和宏" aria-hidden="true">#</a> 大小写转换和宏</h3><p>在以前大小写转换是宏来的，然后宏对于i++这样的参数会造成一定的后果。</p><h3 id="释放内存的问题" tabindex="-1"><a class="header-anchor" href="#释放内存的问题" aria-hidden="true">#</a> 释放内存的问题</h3><p>有些版本的C语言中，要求释放之后才进行重新分配，</p><p>有些版本的C语言在释放之后，可能还会存在一段时间，但这是不那么允许使用的。</p><h3 id="最后一个可移植性的问题的一个例子不知道怎么搞。" tabindex="-1"><a class="header-anchor" href="#最后一个可移植性的问题的一个例子不知道怎么搞。" aria-hidden="true">#</a> 最后一个可移植性的问题的一个例子不知道怎么搞。</h3><h2 id="建议和答案。" tabindex="-1"><a class="header-anchor" href="#建议和答案。" aria-hidden="true">#</a> 建议和答案。</h2>`,139),r=[p];function t(d,c){return n(),e("div",null,r)}const l=a(i,[["render",t],["__file","two.html.vue"]]);export{l as default};
