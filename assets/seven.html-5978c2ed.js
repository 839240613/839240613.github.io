import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as t,e as p}from"./app-82a511c8.js";const e="/assets/images/搜索二叉树建立.svg",o="/assets/images/二叉树.svg",i="/assets/images/二叉树1.png",c="/assets/images/二叉树2.jpg",l="/assets/images/二叉树3.jpg",r="/assets/images/前序遍历1.png",u="/assets/images/前序遍历2.png",n="/assets/images/前序遍历流程图.png",d="/assets/images/中序遍历1.png",k="/assets/images/后序遍历1.png",v="/assets/images/后序遍历2.png",g="/assets/images/后序遍历3.png",m="/assets/images/后序遍历流程图.png",h="/assets/images/二叉树左右.png",b="/assets/images/层序遍历1.png",f="/assets/images/层序遍历2.png",x="/assets/images/层序遍历3.png",y="/assets/images/最低公共结点.png",w="/assets/images/最低公共结点2.png",_="/assets/images/二叉树序列化.jpg",N="/assets/images/折纸.jpg",L="/assets/images/折纸代码.jpg",T={},z=p('<h2 id="二叉树的分类" tabindex="-1"><a class="header-anchor" href="#二叉树的分类" aria-hidden="true">#</a> 二叉树的分类</h2><h3 id="搜索二叉树" tabindex="-1"><a class="header-anchor" href="#搜索二叉树" aria-hidden="true">#</a> 搜索二叉树</h3><p>中序遍历为递增的数列。</p><div style="text-align:center;"><figure><img src="'+e+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p><strong>构建代码：</strong></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>		<span class="token keyword">void</span> <span class="token function">Creat_SearchBinaryTrees</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">ISempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> this<span class="token operator">-&gt;</span>root <span class="token operator">=</span> new <span class="token function">TreeNode</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">else</span><span class="token punctuation">{</span>
			TreeNode<span class="token operator">*</span> p  <span class="token operator">=</span> this<span class="token operator">-&gt;</span>root<span class="token punctuation">;</span>
			TreeNode<span class="token operator">*</span> pre<span class="token punctuation">;</span>
			<span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>
				pre <span class="token operator">=</span> p<span class="token punctuation">;</span>
				p <span class="token operator">=</span> x <span class="token operator">&gt;</span> p<span class="token operator">-&gt;</span>x <span class="token operator">?</span> p<span class="token operator">-&gt;</span>right<span class="token operator">:</span> p<span class="token operator">-&gt;</span>left<span class="token punctuation">;</span>	
			<span class="token punctuation">}</span>
			
			TreeNode<span class="token operator">*</span> Node  <span class="token operator">=</span> new <span class="token function">TreeNode</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>pre<span class="token operator">-&gt;</span>x <span class="token operator">&lt;</span> x<span class="token punctuation">)</span> pre<span class="token operator">-&gt;</span>right <span class="token operator">=</span> Node<span class="token punctuation">;</span>
			<span class="token keyword">else</span> pre<span class="token operator">-&gt;</span>left <span class="token operator">=</span> Node<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>判断代码：</strong></p><p>中序遍历中的打印变成比较即可。</p><h3 id="完全二叉树" tabindex="-1"><a class="header-anchor" href="#完全二叉树" aria-hidden="true">#</a> 完全二叉树</h3><p>判断代码，层序优先遍历</p><p>1、 任一节点，有右无左则返回false。</p><p>2、如果遇到了叶节点，那么接下来遇到的都是叶节点。</p><p>代码借鉴，只有false该ture的操作，没有ture该false的操作，也就是说，一旦成立没有改变的办法。</p><h3 id="平衡二叉树" tabindex="-1"><a class="header-anchor" href="#平衡二叉树" aria-hidden="true">#</a> 平衡二叉树</h3><ul><li><p>红黑树</p></li><li><p>AL树</p></li><li><p>B树</p></li><li><p>B+树</p></li></ul><h2 id="通过遍历构建二叉树" tabindex="-1"><a class="header-anchor" href="#通过遍历构建二叉树" aria-hidden="true">#</a> 通过遍历构建二叉树</h2><p>构建二叉树需要知道根节点，左子树和右子树</p><p>知道中序遍历，再随便知道一个遍历，就可以找到根节点和根节点最近的两个节</p><p>由此推出二叉树结构。</p><h2 id="二叉树的递归序" tabindex="-1"><a class="header-anchor" href="#二叉树的递归序" aria-hidden="true">#</a> 二叉树的递归序</h2><div style="text-align:center;"><figure><img src="`+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>如果1为主函数，则访问的循序为1 2 4 4 4 2 5 5 5 2 1 3 6 6 6 3 7 7 7 3 1</p><div style="text-align:center;"><figure><img src="'+i+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>函数结构</p><p>// 前序</p><p>f(右)</p><p>// 中序</p><p>f(左)</p><p>// 后序</p><p>return；</p><p><strong>代码：</strong></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">inordershow</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
			
			<span class="token function">inordershow</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
			cout<span class="token operator">&lt;&lt;</span>p<span class="token operator">-&gt;</span>x<span class="token operator">&lt;&lt;</span><span class="token char">&#39;\\t&#39;</span><span class="token punctuation">;</span>
			<span class="token function">inordershow</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
			
		
		<span class="token keyword">void</span> <span class="token function">preordershow</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
			
			cout<span class="token operator">&lt;&lt;</span>p<span class="token operator">-&gt;</span>x<span class="token operator">&lt;&lt;</span><span class="token char">&#39;\\t&#39;</span><span class="token punctuation">;</span>
			<span class="token function">inordershow</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">inordershow</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
			
			
		<span class="token keyword">void</span> <span class="token function">postordershow</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
			
			<span class="token function">postordershow</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">postordershow</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
			cout<span class="token operator">&lt;&lt;</span>p<span class="token operator">-&gt;</span>x<span class="token operator">&lt;&lt;</span><span class="token char">&#39;\\t&#39;</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>前序遍历就是在//的位置加入printf，则这个函数输出为第一次的出现的数字，</li></ul><p>即 1 2 4 5 3 6 7</p><ul><li>中序遍历就是在//的位置加入printf，则这个函数输出为第二次的出现的数字，</li></ul><p>即 4 2 5 1 6 3 7</p><ul><li>后序遍历就在//的位置加入printf，则这个函数输出为第三次出现的数字，</li></ul><p>即 4 5 2 6 7 3 1</p><h3 id="前序遍历模型" tabindex="-1"><a class="header-anchor" href="#前序遍历模型" aria-hidden="true">#</a> 前序遍历模型</h3><p>递归模型可以快速得出前序遍历。</p><h3 id="中序遍历模型" tabindex="-1"><a class="header-anchor" href="#中序遍历模型" aria-hidden="true">#</a> 中序遍历模型</h3><div style="text-align:center;"><figure><img src="`+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>快速获取中序遍历。</p><h3 id="后序遍历模型" tabindex="-1"><a class="header-anchor" href="#后序遍历模型" aria-hidden="true">#</a> 后序遍历模型</h3><div style="text-align:center;"><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>快速获取后序遍历。</p><h2 id="非递归排序-自己压栈" tabindex="-1"><a class="header-anchor" href="#非递归排序-自己压栈" aria-hidden="true">#</a> 非递归排序（自己压栈）</h2><h3 id="前序遍历" tabindex="-1"><a class="header-anchor" href="#前序遍历" aria-hidden="true">#</a> 前序遍历</h3><p>放入头结点</p><p>--- //第一层循环</p><ul><li><ol><li>打印 //第二层循环</li></ol></li><li><ol start="2"><li>放结点入栈</li></ol></li><li><ol start="3"><li>取左指针 //第二层循环</li></ol></li></ul><p>弹出取右边。</p><hr><h4 id="动作" tabindex="-1"><a class="header-anchor" href="#动作" aria-hidden="true">#</a> <strong>动作：</strong></h4><p>一开始把左结点穷尽。</p><div style="text-align:center;"><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>然后弹出栈顶，找右子树，4没有右子树不要4。</p><p>2有右子树，5进栈，把5的左结点穷尽，然后弹出，找右子树。</p><div style="text-align:center;"><figure><img src="'+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>上图中5都没有直接放掉，找3的，然后穷尽3的节点，重复这样的操作。</p><h4 id="流程图" tabindex="-1"><a class="header-anchor" href="#流程图" aria-hidden="true">#</a> <strong>流程图：</strong></h4><div style="text-align:center;"><figure><img src="'+n+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p><strong>代码：</strong></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">preorderTraversal_stack</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   TreeNode<span class="token operator">*</span> current <span class="token operator">=</span> node<span class="token punctuation">;</span>
   TreeNode<span class="token operator">*</span> stack<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
   <span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

   <span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">||</span> top <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d &quot;</span><span class="token punctuation">,</span> current<span class="token operator">-&gt;</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
           stack<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> current<span class="token punctuation">;</span>
           current <span class="token operator">=</span> current<span class="token operator">-&gt;</span>left<span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       current <span class="token operator">=</span> stack<span class="token punctuation">[</span>top<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
       current <span class="token operator">=</span> current<span class="token operator">-&gt;</span>right<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>比链表多一个while的原因是在第一次找到NULL的时候，树并没有结束。</p></li><li><p>不断的放进左树，然后再弹出，再放右树。原理是，头结点和左树都在左树，</p></li></ul><p>左树没有左节点那就是根，放入右节点继续找左和右树</p><h3 id="中序遍历" tabindex="-1"><a class="header-anchor" href="#中序遍历" aria-hidden="true">#</a> 中序遍历</h3><p>放入头结点</p><p>-- //第一层循环</p><ul><li><ol><li>放结点入栈</li></ol></li><li><ol start="2"><li>取左指针 //第二层循环</li></ol></li></ul><p>弹出</p><p>打印</p><p>取右</p><p>--</p><h4 id="动作-1" tabindex="-1"><a class="header-anchor" href="#动作-1" aria-hidden="true">#</a> <strong>动作：</strong></h4><p>流程一模一样。但是是出栈才打印。</p><div style="text-align:center;"><figure><img src="`+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><h4 id="流程图-1" tabindex="-1"><a class="header-anchor" href="#流程图-1" aria-hidden="true">#</a> <strong>流程图：</strong></h4><div style="text-align:center;"><figure><img src="'+n+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p><strong>代码：</strong></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">inorderTraversal_stack</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   TreeNode<span class="token operator">*</span> current <span class="token operator">=</span> node<span class="token punctuation">;</span>
   TreeNode<span class="token operator">*</span> stack<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
   <span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

   <span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">||</span> top <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           stack<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> current<span class="token punctuation">;</span>
           current <span class="token operator">=</span> current<span class="token operator">-&gt;</span>left<span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       current <span class="token operator">=</span> stack<span class="token punctuation">[</span>top<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
       <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d &quot;</span><span class="token punctuation">,</span> current<span class="token operator">-&gt;</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
       current <span class="token operator">=</span> current<span class="token operator">-&gt;</span>right<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="后序遍历" tabindex="-1"><a class="header-anchor" href="#后序遍历" aria-hidden="true">#</a> 后序遍历</h3><h4 id="动作-2" tabindex="-1"><a class="header-anchor" href="#动作-2" aria-hidden="true">#</a> <strong>动作：</strong></h4><p>前部分流程一样，穷尽左节点。</p><div style="text-align:center;"><figure><img src="`+k+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>然后弹出4判断有没有右节点，没有才打印。</p><p>判断2有右节点，把2放回栈，把5放进栈，穷尽左节点，再判断有没有右节点，没有才打印。</p><div style="text-align:center;"><figure><img src="'+v+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>再次弹出2，右节点是上一个遍历的节点，所以可以打印。</p><div style="text-align:center;"><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><h4 id="流程图-2" tabindex="-1"><a class="header-anchor" href="#流程图-2" aria-hidden="true">#</a> <strong>流程图</strong></h4><p><strong>总体来说就是穷尽左节点，然后对打印的条件加以限制，没有被打印的节点放回栈中等待条件成立。</strong></p><ul><li>很完美的条件就是上一个节点正好是右节点。</li></ul><div style="text-align:center;"><figure><img src="'+m+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p><strong>代码</strong>：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">postorderTraversal_stack</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   TreeNode<span class="token operator">*</span> current <span class="token operator">=</span> node<span class="token punctuation">;</span>
   TreeNode<span class="token operator">*</span> stack<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
   <span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
   TreeNode<span class="token operator">*</span> prev <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

   <span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">||</span> top <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           stack<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> current<span class="token punctuation">;</span>
           current <span class="token operator">=</span> current<span class="token operator">-&gt;</span>left<span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       current <span class="token operator">=</span> stack<span class="token punctuation">[</span>top<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token operator">-&gt;</span>right <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> current<span class="token operator">-&gt;</span>right <span class="token operator">==</span> prev<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d &quot;</span><span class="token punctuation">,</span> current<span class="token operator">-&gt;</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
           prev <span class="token operator">=</span> current<span class="token punctuation">;</span>
           current <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
           stack<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> current<span class="token punctuation">;</span>
           current <span class="token operator">=</span> current<span class="token operator">-&gt;</span>right<span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>把所有左的节点都放进栈里，取出后的时候判断有没有右节点或者右节点是否被遍历，</li></ul><p>如果有右节点，并且没有被遍历，那么放目前节点回栈，然后对右节点的进行所有的左节点进栈......</p><p>这样做的原因是，左边遍历到NULL其实弹出的左节点是根节点，由于左右根，所以根是不可以打印的，必须右边打印才行，</p><p>同时这个根节点又是上一个的左节点，因此是打印了左节点，那么就进入上一级的树的遍历了。</p><p><strong>这样栈中就会有比较多的树等待着条件允许才被打印。</strong></p><h3 id="总体思路" tabindex="-1"><a class="header-anchor" href="#总体思路" aria-hidden="true">#</a> 总体思路：</h3><p>把树分为左树和右数。</p><div style="text-align:center;"><figure><img src="`+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>通过两层循环和判断条件从中获取信息。</p><h2 id="层序遍历" tabindex="-1"><a class="header-anchor" href="#层序遍历" aria-hidden="true">#</a> 层序遍历</h2><h3 id="通过队列来帮助实现" tabindex="-1"><a class="header-anchor" href="#通过队列来帮助实现" aria-hidden="true">#</a> 通过队列来帮助实现</h3><ul><li>第一步: 放入头结点</li></ul><div style="text-align:center;"><figure><img src="'+b+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><ul><li>第二步: 取出结点打印，先放入左孩子，再放入右孩子</li></ul><div style="text-align:center;"><figure><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><ul><li>重复第二步，直到队列空</li></ul><div style="text-align:center;"><figure><img src="'+x+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p><strong>代码：</strong></p><p>宽度优先遍历的斧头，用一个数组嵌套数组记录每一层的数据。</p><p>通过在取队列之前，对队列的大小进行记录，就可以知道这层的数量。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">Sequence_traversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
			
			deque<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">&gt;</span> Maximum<span class="token punctuation">;</span>
			vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">;</span>
			Maximum<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
			
			<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>Maximum<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
				<span class="token keyword">int</span> size <span class="token operator">=</span> Maximum<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> temp<span class="token punctuation">;</span>
				
				<span class="token keyword">while</span><span class="token punctuation">(</span>size<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
					p <span class="token operator">=</span> Maximum<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Maximum<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				
					temp<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
				
					<span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span> Maximum<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span>Maximum<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
					
				arr<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			
			<span class="token keyword">for</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator it <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">!=</span>arr<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
				<span class="token keyword">for</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator vit <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vit<span class="token operator">!=</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vit<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
					cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>vit<span class="token operator">&lt;&lt;</span><span class="token char">&#39;\\t&#39;</span><span class="token punctuation">;</span> 
				<span class="token punctuation">}</span>
				cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			
			<span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="找到最宽的层" tabindex="-1"><a class="header-anchor" href="#找到最宽的层" aria-hidden="true">#</a> 找到最宽的层</h2><p>解决的问题就是怎么分层，</p><p>记住层数的最后一个结点，记录这层最后一个结点，在换层之前记录下一层的最后一个结点，</p><p><strong>在上面的代码就可以导出一个嵌套数组完成这件事情。</strong></p><h2 id="找到最低的公共结点。" tabindex="-1"><a class="header-anchor" href="#找到最低的公共结点。" aria-hidden="true">#</a> 找到最低的公共结点。</h2><p><strong>思维模式：</strong></p><p>情况一：</p><div style="text-align:center;"><figure><img src="`+y+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>情况二：</p><div style="text-align:center;"><figure><img src="'+w+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p><strong>代码：</strong></p><p>这个代码其实就是后序遍历的进阶版，</p><p>利用后续遍历的特性，回收结点以下的信息。</p><p>递归需要注意至少有两个返回，一个是结点有数的返回，一个是结点为空的返回。</p><p>在基本的整体条件封锁下，加上你特定的条件就好。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>TreeNode<span class="token operator">*</span> <span class="token function">find_same</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> p<span class="token punctuation">,</span>TreeNode<span class="token operator">*</span> o1<span class="token punctuation">,</span>TreeNode<span class="token operator">*</span> o2<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token operator">||</span>p<span class="token operator">==</span>o1<span class="token operator">||</span>p<span class="token operator">==</span>o2<span class="token punctuation">)</span> <span class="token keyword">return</span> p<span class="token punctuation">;</span>

TreeNode<span class="token operator">*</span> left <span class="token operator">=</span> <span class="token function">find_same</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span>o1<span class="token punctuation">,</span>o2<span class="token punctuation">)</span><span class="token punctuation">;</span>
TreeNode<span class="token operator">*</span> right <span class="token operator">=</span> <span class="token function">find_same</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span>o1<span class="token punctuation">,</span>o2<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">&amp;&amp;</span>right<span class="token punctuation">)</span> <span class="token keyword">return</span> p<span class="token punctuation">;</span>
            
<span class="token keyword">return</span> left <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token operator">?</span> left<span class="token operator">:</span>right<span class="token punctuation">;</span>
		 <span class="token punctuation">}</span>  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="别的方法" tabindex="-1"><a class="header-anchor" href="#别的方法" aria-hidden="true">#</a> 别的方法</h3><p>建立一个map表，上面有子结点，父节点两个信息。</p><p>然后用一个o1结点网上找，制作一个Hash表。</p><p>用02来往上走，查看是否在Hash表里。</p><p>其中map表的建立是在主函数创建，然后作为参数输入，不断的递归调用补充。</p><h2 id="从结构中找到后继结点" tabindex="-1"><a class="header-anchor" href="#从结构中找到后继结点" aria-hidden="true">#</a> 从结构中找到后继结点</h2><p>需要能够找到父节点</p><ul><li><p>X有右树的时候，右树的最左结点一定是后继节点。</p></li><li><p>X往上遍历，第一个有左孩子的结点。</p></li></ul><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">F</span><span class="token punctuation">(</span>结点X<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    边界条件

    <span class="token keyword">if</span><span class="token punctuation">(</span>X有右树<span class="token punctuation">)</span><span class="token punctuation">{</span>
        串到右树的最左边。
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span><span class="token punctuation">{</span> <span class="token comment">//无右子树</span>
        建立父节点
        <span class="token keyword">while</span><span class="token punctuation">(</span>父节点<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token operator">&amp;&amp;</span>父节点<span class="token operator">-&gt;</span>左孩子<span class="token operator">!=</span>X<span class="token punctuation">)</span><span class="token punctuation">{</span>
            X <span class="token operator">=</span> 父节点<span class="token punctuation">;</span>
            父节点 <span class="token operator">=</span> 父节点<span class="token operator">-&gt;</span>父节点<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> 结点。
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="二叉树的序列化和反序列化" tabindex="-1"><a class="header-anchor" href="#二叉树的序列化和反序列化" aria-hidden="true">#</a> 二叉树的序列化和反序列化</h2><p>把二叉树变成唯一的字符串，用于存储在硬盘中。</p><p>对于一个需要不断累计的递归方式</p><div style="text-align:center;"><figure><img src="`+_+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><h3 id="反序列化" tabindex="-1"><a class="header-anchor" href="#反序列化" aria-hidden="true">#</a> 反序列化</h3><p>把字符串变成队列，然后根据序列化的排序方式，构建二叉树。</p><h2 id="折纸" tabindex="-1"><a class="header-anchor" href="#折纸" aria-hidden="true">#</a> 折纸</h2><h3 id="思维模式" tabindex="-1"><a class="header-anchor" href="#思维模式" aria-hidden="true">#</a> 思维模式</h3><p>每次折纸都会在原先的折痕上建立左右两个孩子，</p><p>并且这棵树的特点是，左树都是凹，右数都是凸</p><div style="text-align:center;"><figure><img src="'+N+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><h3 id="代码" tabindex="-1"><a class="header-anchor" href="#代码" aria-hidden="true">#</a> 代码</h3><p>简单的利用二叉树的中序遍历，用一个bool来省去二叉树的结构，判断打印的值。</p><div style="text-align:center;"><figure><img src="'+L+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>无非就是左子树还是右子树的访问，用bool来解决。</p><p>通过不断往下的递归实现了每一层数量翻倍的效果，</p><h2 id="二叉树板斧" tabindex="-1"><a class="header-anchor" href="#二叉树板斧" aria-hidden="true">#</a> 二叉树板斧</h2><ul><li><p>记录上一个访问的节点</p></li><li><p>树型递归（树形DP）</p><ul><li>分析左树和右数需要什么</li><li>构成一个结构体需要的东西</li><li>向左树和右树拿东西再回去</li></ul></li><li><p>后序递归</p></li></ul>',160),U=[z];function q(M,X){return a(),t("div",null,U)}const S=s(T,[["render",q],["__file","seven.html.vue"]]);export{S as default};
