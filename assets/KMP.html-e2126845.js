import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as e,o as p,c as i,a as n,b as o,d as c,e as s}from"./app-e4bb05b4.js";const l="/assets/images/岛问题.png",r="/assets/images/并查集.png",u="/assets/images/并查集并行运算.png",d="/assets/images/并查集记录边界.png",k="/assets/images/暴力字符串匹配.gif",m="/assets/images/KMP.png",g="/assets/images/KMP1.png",v="/assets/images/KMP2.png",h="/assets/images/KMP流程图分析1.png",b="/assets/images/KMP流程图分析2.png",x="/assets/images/next数组.png",f="/assets/images/next数组1.png",y="/assets/images/next数组3.png",_={},w=s('<h2 id="并查集" tabindex="-1"><a class="header-anchor" href="#并查集" aria-hidden="true">#</a> 并查集</h2><h3 id="以下列问题引出并查集" tabindex="-1"><a class="header-anchor" href="#以下列问题引出并查集" aria-hidden="true">#</a> 以下列问题引出并查集：</h3><div style="text-align:center;"><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>上图中，求解1联结的区域有几个，联结的区域被称为岛。例如，上图中只有一个岛。</p><p>解决这个问题需要两个图的深层遍历(DFS)即可。</p><p>第一个遍历整个图，为1则进入第二重遍历</p><p>第二个遍历，把1改为2，然后遍历有1的都改为2，为0的退出这个遍历过程。</p><p>这个遍历过程称为感染（infect）。</p><ul><li>时间问题：</li></ul><p>O(N*M)</p><p>N为矩阵的行，M为矩阵的列。第一次遍历整个矩阵，然后一个位置最多会被感染四次，</p><p>所以就是5个N*M这个数量级的时间。</p><div style="text-align:center;"><p><strong>如果整个矩阵变得非常大，一个cpu遍历会比较慢，</strong></p><p><strong>并查集就是多个cpu合作解决这种问题的数据结构。</strong></p></div><h3 id="并查集内容" tabindex="-1"><a class="header-anchor" href="#并查集内容" aria-hidden="true">#</a> 并查集内容</h3><p>我需要一个数据结构能够解决两个问题</p><ul><li>O(1)时间合并两个集合-&gt;Union.</li><li>O(1)时间查询是否是一个集合-&gt;issameset.</li></ul><p>链表可以快速的解决第一个问题，但第二个问题会很麻烦。</p><p>哈希表可以快速的解决第二个问题，但第一个问题会很慢。</p><p>因此需要一种新的数据结构，如下图所示：</p><div style="text-align:center;"><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>完美适配上述两个问题，其中和合并的方式如上图所示</p><p>相等的查找方式如图所示，如果是查找c和b是否相等，</p><p>只需要往上找父指针，如果父指针一致，那么就是相等的。</p><ul><li>实现方式</li></ul><p>看起来像是链表，其实是三个哈希表.</p><ul><li>第一个表，记录元素和元素的父元素</li><li>第二个表，记录集合和集合个数</li><li>第三个表，记录元素和集合的最高父元素</li></ul><h3 id="解决方法" tabindex="-1"><a class="header-anchor" href="#解决方法" aria-hidden="true">#</a> 解决方法：</h3><div style="text-align:center;"><figure><img src="'+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>左边计算完，记录边界。右边计算完记录边界</p><div style="text-align:center;"><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>当边界不相等且临近的的时候，如上图所示，A!=C则总数-1</p><p>因此，本来左边2个，右边2个。经过计算变成了4-2为2个岛。</p><p><strong>这只是简单了解，虽然这个题目好像也不需要并查集，数组和边界就可以完成并行运算，</strong></p><p><strong>但是并查集在多CPU运算中是非常强大的数据结构</strong></p><h2 id="kmp" tabindex="-1"><a class="header-anchor" href="#kmp" aria-hidden="true">#</a> KMP</h2><ul><li>描述</li></ul><p>str1中是否存在str2。</p><ul><li>暴力算法 一个一个的比较，不对就移动。</li></ul><div style="text-align:center;"><figure><img src="'+k+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><ul><li>KMP算法通过字符串的特性进行了加速比较。</li></ul><div style="text-align:center;"><figure><img src="'+m+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>如上图所示，暴力算法在处于黑色箭头位置的时候，</p><p>也就是上字符串为s，下字符串为z的时候，倒回红色箭头的位置重新比较，</p><p>然后KMP是倒回图中长箭头的位置进行比较。</p><p>KMP相当于暴力算法的一个小加速，为什么可以这样小加速并且不会出错呢？</p><h3 id="kmp实行的原理-为什么可以这样小加速" tabindex="-1"><a class="header-anchor" href="#kmp实行的原理-为什么可以这样小加速" aria-hidden="true">#</a> KMP实行的原理(为什么可以这样小加速)</h3><p>KMP做了两件事，让这个这个事情成立</p><ul><li>第一件事</li></ul><p>最后匹配的不同字符之前，所有的字符都一致，根据<strong>最大前后缀</strong>可以进行图中长箭头的匹配。</p>',49),M={href:"https://blog.csdn.net/moodfriend/article/details/105797346",target:"_blank",rel:"noopener noreferrer"},z=s('<div style="text-align:center;"><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>上图中，s和z字符之前都一样，这是一一比较过来的毫无异议。</p><p>因为一样，所以上字符串的前后缀1和2，</p><p>下字符串的前后缀1和2，都一样，</p><p>2和4一样，4和3一样，那么就比较2后面的3后面的一不一样就好了。</p><ul><li>第二件事</li></ul><p>在上字符串后缀（2）中，其前面的任意一个位置的字符串都不可能匹配出下字符串。</p><div style="text-align:center;"><figure><img src="'+v+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>上述问题就是k中可以匹配下字符串。这是根本不可能的事情。</p><p>用反证法比较容易理解、</p><p>假设j位置就是上字符串的后缀，如果k之后能够包含下字符串，</p><p>那么k之后的要不就能够包含下字符串全部，要不就包含下字符串的前缀。</p><p>为什么是前缀？因为上字符串和下字符串在s和z之前是一模一样的，</p><p>k之后也正是后缀，所以必须是前缀。</p><p>如果有那么长的前缀，那么就会有这么长的后缀，k比j长，那么就说明原来的后缀不是最长的后缀，</p><p>前后矛盾了。所以k就不可能可以匹配字符串。</p><p><strong>最长前后缀的概念很强大，贯穿始终，理解起来都很抽象，但是有非常的有逻辑有道理。</strong></p><p><strong>强大的前人们。</strong></p><h3 id="kmp思考模式" tabindex="-1"><a class="header-anchor" href="#kmp思考模式" aria-hidden="true">#</a> KMP思考模式</h3><ul><li>第一种，根据字符串的运动情况来分析迭代的方法</li></ul><div style="text-align:center;"><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><ul><li>第二种，根据字符串对比过程是否相等来分析迭代的方法。</li></ul><div style="text-align:center;"><figure><img src="'+b+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>无论怎么分析，最终得出来的都是三种运动状态，并且得到三种运动状态切换的条件。</p><h3 id="kmp代码实现" tabindex="-1"><a class="header-anchor" href="#kmp代码实现" aria-hidden="true">#</a> KMP代码实现</h3><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">KMP</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> str1<span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span> str2<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">// boundary</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>str1<span class="token operator">==</span><span class="token constant">NULL</span><span class="token operator">|</span>str2<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token comment">//initailize</span>
	<span class="token keyword">int</span> i1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> i2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token comment">//execution</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>str1<span class="token punctuation">[</span>i1<span class="token punctuation">]</span> <span class="token operator">!=</span><span class="token char">&#39;\\0&#39;</span><span class="token operator">&amp;&amp;</span> str2<span class="token punctuation">[</span>i2<span class="token punctuation">]</span> <span class="token operator">!=</span><span class="token char">&#39;\\0&#39;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>str1<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token operator">==</span>str2<span class="token punctuation">[</span>i2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token comment">//matching succesfully</span>
		i1<span class="token operator">++</span><span class="token punctuation">;</span>i2<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>i2<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token comment">// Bcak to the end</span>
		 i1<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
		i2<span class="token operator">=</span> next<span class="token punctuation">[</span>i2<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token punctuation">}</span>
		
	<span class="token keyword">return</span> str2<span class="token punctuation">[</span>i2<span class="token punctuation">]</span><span class="token operator">==</span><span class="token char">&#39;\\0&#39;</span><span class="token operator">?</span> i1<span class="token operator">-</span>i2 <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="next数组的思考模式" tabindex="-1"><a class="header-anchor" href="#next数组的思考模式" aria-hidden="true">#</a> next数组的思考模式</h3><p>动态规划： 用已知或者前置的条件，一步一步的推导出想要的东西。</p><div style="text-align:center;"><figure><img src="`+x+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>求取空白字符串的next数组时，如果？为e和str[8]一致，则匹配成功，数值为8+1。</p><p>如果？为s和str[8]不一致，则匹配失败，寻找str[3]匹配是否一致。</p><ul><li><p>这样可以求出next数组来源于两个方面：</p></li><li><ol><li>新的next数组数值不会比前一个next数值大2以上的数字，</li></ol></li></ul><p>一旦大于或者等于2，那么前面的next数组就失效了，前面的都能够找到更大的，</p><p>是前后矛盾的。</p><ul><li><ol start="2"><li>永远都聚焦于？和谁一样。</li></ol></li></ul><div style="text-align:center;"><figure><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>一开始比对的是不相等的指示线，由next数组可以了解到1和2是一致的，</p><p>第二次对比是3前缀后和i前一个字符串比对。</p><p>为什么可以这样比对得到i的next数组是因为相等的传递性，一直传递过去的。</p><p>1和2相等，那么3,4,5,6都是相等的，3自然就和6是相等的，所以这样比对。</p><h3 id="next行为分析" tabindex="-1"><a class="header-anchor" href="#next行为分析" aria-hidden="true">#</a> next行为分析：</h3><div style="text-align:center;"><figure><img src="'+y+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>只有三个红点的结果，三个结果对应着三个触发状态变换的条件。以此来进行迭代。</p><h3 id="时间复杂度" tabindex="-1"><a class="header-anchor" href="#时间复杂度" aria-hidden="true">#</a> 时间复杂度：</h3><p>有三种运动状态：</p><table><thead><tr><th style="text-align:center;">运动方式</th><th style="text-align:center;">i1(max-&gt;N)</th><th style="text-align:center;">i1-i2(max-&gt;N)</th></tr></thead><tbody><tr><td style="text-align:center;">1)</td><td style="text-align:center;">上升</td><td style="text-align:center;">不变</td></tr><tr><td style="text-align:center;">2)</td><td style="text-align:center;">上升</td><td style="text-align:center;">上升</td></tr><tr><td style="text-align:center;">3)</td><td style="text-align:center;">不变</td><td style="text-align:center;">上升</td></tr></tbody></table><p>因此时间复杂度都是2*O(N)。</p><h3 id="next数组代码实现" tabindex="-1"><a class="header-anchor" href="#next数组代码实现" aria-hidden="true">#</a> next数组代码实现</h3><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">make_next</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">// boundary</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">==</span><span class="token constant">NULL</span><span class="token operator">|</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token comment">// initailize</span>
	next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>next<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> point <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">//the str number.</span>
	<span class="token keyword">int</span> cn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// the next number.</span>
	<span class="token comment">//execution</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>point<span class="token punctuation">]</span> <span class="token operator">!=</span><span class="token char">&#39;\\0&#39;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">//match the next array in front.</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token punctuation">(</span>point<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">==</span> p<span class="token punctuation">[</span>cn<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token comment">// Match successfully</span>
		next<span class="token punctuation">[</span>point<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">++</span>cn<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>cn <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token comment">//next number == 0</span>
		next<span class="token punctuation">[</span>point<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
		<span class="token comment">//next recall</span>
		cn <span class="token operator">=</span> next<span class="token punctuation">[</span>cn<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">}</span>
	
	<span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="容易出现的理解偏差" tabindex="-1"><a class="header-anchor" href="#容易出现的理解偏差" aria-hidden="true">#</a> 容易出现的理解偏差</h3><ul><li><ol><li>next数组是比str2少一个的，这样就能用了。</li></ol></li><li><ol start="2"><li>next数组的cn注意是++cn。</li></ol></li></ul>`,51);function P(K,N){const a=e("ExternalLinkIcon");return p(),i("div",null,[w,n("p",null,[n("a",M,[o("前后缀是什么"),c(a)])]),z])}const B=t(_,[["render",P],["__file","KMP.html.vue"]]);export{B as default};
