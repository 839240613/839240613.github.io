import{_ as l}from"./plugin-vue_export-helper-c27b6911.js";import{r as a,o as i,c as r,a as t,b as n,d,e as s}from"./app-e4bb05b4.js";const o={},c={href:"https://zhuanlan.zhihu.com/p/458976914?utm_campaign=shareopn&utm_medium=social&utm_oi=1223989907297169408&utm_psn=1720257167116836864&utm_source=wechat_session&utm_id=0",target:"_blank",rel:"noopener noreferrer"},h=s('<ul><li>编译器和解析器最本质的区别：</li></ul><p>编译器-&gt; 输出的是可执行文件</p><p>解析器-&gt; 输出结果</p><p>编译器的五大步骤：</p><table><thead><tr><th style="text-align:center;">步骤</th><th style="text-align:center;">英语名称</th><th style="text-align:center;">中文名称</th><th style="text-align:center;">描述</th></tr></thead><tbody><tr><td style="text-align:center;">1</td><td style="text-align:center;">Lexical Analysis</td><td style="text-align:center;">词法分析</td><td style="text-align:center;">空格和关键字的分析</td></tr><tr><td style="text-align:center;">2</td><td style="text-align:center;">Pouring</td><td style="text-align:center;">解析</td><td style="text-align:center;">为什么要运算符</td></tr><tr><td style="text-align:center;">3</td><td style="text-align:center;">Sementic Analysis</td><td style="text-align:center;">语义分析</td><td style="text-align:center;">句子分析</td></tr><tr><td style="text-align:center;">4</td><td style="text-align:center;">Optimization</td><td style="text-align:center;">优化</td><td style="text-align:center;">进行相同语句的优化</td></tr><tr><td style="text-align:center;">5</td><td style="text-align:center;">Code Generation</td><td style="text-align:center;">代码生成</td><td style="text-align:center;">生成二进制或者其他代码</td></tr></tbody></table><h2 id="谈论了一个为什么会有新语言的出现" tabindex="-1"><a class="header-anchor" href="#谈论了一个为什么会有新语言的出现" aria-hidden="true">#</a> 谈论了一个为什么会有新语言的出现</h2><h3 id="设计一种语言-各种的侧重" tabindex="-1"><a class="header-anchor" href="#设计一种语言-各种的侧重" aria-hidden="true">#</a> 设计一种语言，各种的侧重</h3><ul><li><ol><li>在科学方面</li></ol><ul><li>good FP 好的浮点数运算。</li><li>good arr</li><li>parallelism</li></ul></li><li><ol start="2"><li>业务方面</li></ol></li><li><p>persistent 持久与稳定</p></li><li><p>good report 好的报告能力</p></li><li><p>data anlysis 数据分析能力</p></li><li><ol start="3"><li>系统方面</li></ol><ul><li>control of resource</li><li>realtime consistant 在网络和一些设备需要对动作进行一定的反应。</li></ul></li></ul><h3 id="旧语言和新语言的适用范围" tabindex="-1"><a class="header-anchor" href="#旧语言和新语言的适用范围" aria-hidden="true">#</a> 旧语言和新语言的适用范围</h3><ul><li><ol><li>都是为了让程序更容易理解。</li></ol></li><li><ol start="2"><li>广泛的语言因为受用的人很多，所以尝试改变的风险很大。</li></ol></li><li><ol start="3"><li>新语言就可以快速的改变，因为受用的群体比较小，所以学习成本就会小很多。</li></ol></li></ul><p><strong>其实没有很懂这里的逻辑。</strong></p><h2 id="关于操作系统栈的相关东西" tabindex="-1"><a class="header-anchor" href="#关于操作系统栈的相关东西" aria-hidden="true">#</a> 关于操作系统栈的相关东西</h2><p>栈的开辟是从大到小的，而数据记录是从小到大的，</p><p>因此字符串拷贝等这些函数如果没有数据长度的匹配，会导致栈溢出，出现bug。</p><p>函数的调用过程。</p><p>知乎的书架有一步一步的流程图。</p><h2 id="编译器的第一步词法分析" tabindex="-1"><a class="header-anchor" href="#编译器的第一步词法分析" aria-hidden="true">#</a> 编译器的第一步词法分析</h2><p>一个一个的读取该语言规定的字符串。</p><h3 id="状态转换图" tabindex="-1"><a class="header-anchor" href="#状态转换图" aria-hidden="true">#</a> 状态转换图</h3><p>词法分析中有一个状态转换图的同，就像梯形图一样，根据对应的口进入下一个口接着判断接下来的口。</p><h2 id="编译器的第二步语法分析" tabindex="-1"><a class="header-anchor" href="#编译器的第二步语法分析" aria-hidden="true">#</a> 编译器的第二步语法分析</h2><p>把从上面词法分析中得到的token以C语言语法为模版，将符号串按序逐个匹配。</p><p>但是有实际的用法中，函数的参数个数是不受限制的，语法规则是随意变化的。</p><h3 id="产生式" tabindex="-1"><a class="header-anchor" href="#产生式" aria-hidden="true">#</a> 产生式</h3><p>产生式就是用来判别语法</p><p>本质就是定义一个符号，然后用符号和符号进行匹配</p><p>在符号之间的转换过程中，会出现左递归的情况。</p><h3 id="语法树" tabindex="-1"><a class="header-anchor" href="#语法树" aria-hidden="true">#</a> 语法树</h3><p>根据产生式得出的结果放入一树中，每一个产生式的结果在不同的树中。</p>',29);function p(x,u){const e=a("ExternalLinkIcon");return i(),r("div",null,[t("p",null,[t("a",c,[n("编译器与解释器的区别"),d(e)])]),h])}const _=l(o,[["render",p],["__file","one.html.vue"]]);export{_ as default};
