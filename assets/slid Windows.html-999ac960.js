import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{o as t,c as a,e}from"./app-e4bb05b4.js";const n="/assets/images/滑动窗口1.png",s="/assets/images/滑动窗口2.png",l="/assets/images/滑动窗口3.png",g="/assets/images/滑动窗口4.png",r="/assets/images/滑动窗口5.png",p="/assets/images/滑动窗口6.png",o="/assets/images/单调栈1.png",c="/assets/images/单调栈2.png",d="/assets/images/单调栈3.png",f="/assets/images/单调栈4.png",u="/assets/images/单调5.png",m={},_=e('<h2 id="滑动窗口" tabindex="-1"><a class="header-anchor" href="#滑动窗口" aria-hidden="true">#</a> 滑动窗口</h2><p>滑动窗口游双端队列维护。窗口是任意变化的，<strong>窗口的内容是最大值的优先级</strong></p><ul><li>运动状态：</li></ul><div style="text-align:center;"><figure><img src="'+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>滑动窗口就是运用双端列表的性质，如上图所示，</p><p>W的右边界移动，把数组放入双端队列，</p><p>W的左边界移动，把双端队列的数组弹出，</p><p>根据弹出和放入的内容，可以实现窗口内最大值、窗口内和、等等数据。</p><ul><li>实现窗口内最大值的查找</li></ul><p>维持双端队列由大到小的排列</p><div style="text-align:center;"><figure><img src="'+s+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><div style="text-align:center;"><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>当5放进去的时候，由于5&gt;3,因此3被弹出，</p><div style="text-align:center;"><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>当窗口需要缩小的时候，</p><p>需要判断左边界是否等于队列的最左边的数，是才弹出</p><div style="text-align:center;"><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>不是则缩小窗口即可。</p><div style="text-align:center;"><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><h3 id="需要注意的问题" tabindex="-1"><a class="header-anchor" href="#需要注意的问题" aria-hidden="true">#</a> 需要注意的问题</h3><ul><li><ol><li>L不能越过R</li></ol></li><li><ol start="2"><li>在上述问题中，双端队列存放的数据是窗口最大值的优先级。</li></ol></li></ul><p>由处于数组的位置和数据的大小来决定。</p><ul><li><ol start="3"><li>相同的数放掉数组左边的。</li></ol></li></ul><h2 id="单调栈" tabindex="-1"><a class="header-anchor" href="#单调栈" aria-hidden="true">#</a> 单调栈</h2><p>单调栈解决找下一个更合适的值的问题，NEXT great。</p><p><strong>下面解决的是寻找数周围比他大的值。</strong></p><ul><li>运动状态</li></ul><div style="text-align:center;"><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>当指针运动到3的时候，3&lt;6，因此放入栈。</p><div style="text-align:center;"><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>当指针运动到5的时候，5&gt;3，因此3被弹出，5放入栈。</p><p>于此同时就可以记录3的信息了。</p><p>左边大于3的数是栈顶的数，右边大于3的数是指针的数。</p><div style="text-align:center;"><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>当指针运动到最后，栈中还有元素，那么全部弹出，记录的右边大于其的数值为0。</p><p>没有弹出前：</p><div style="text-align:center;"><figure><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>弹出后：</p><div style="text-align:center;"><figure><img src="'+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p><strong>寻找一个数组中最小值乘上最小值所在的数组的和的最大值</strong></p><p>不断寻找这个数作为比他小的作为数组的边界，就能够得到这个最大值。也就是单调栈。</p><h3 id="需要注意的问题-1" tabindex="-1"><a class="header-anchor" href="#需要注意的问题-1" aria-hidden="true">#</a> 需要注意的问题</h3><ul><li><ol><li>相同数压在一起即可。</li></ol></li></ul><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><p>单调栈擅长靠近的最大值最小值，由此衍生的问题，</p><p>滑动窗口擅长于寻找整个窗口的最大值最小值、处理窗口内一些数的信息等，由此衍生的问题。</p>',46),h=[_];function x(v,y){return t(),a("div",null,h)}const W=i(m,[["render",x],["__file","slid Windows.html.vue"]]);export{W as default};
