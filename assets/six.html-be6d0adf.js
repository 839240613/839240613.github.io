import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as a,e as t}from"./app-e4bb05b4.js";const e="/assets/images/链表三指针.png",p="/assets/images/快慢指针.png",o="/assets/images/快慢指针流程图.svg",i="/assets/images/最快回文链表流程图.svg",c="/assets/images/随机链表.png",l="/assets/images/随机链表2.png",r="/assets/images/随机链表3.png",u="/assets/images/随机节点链表.png",d="/assets/images/链表相交.png",k="/assets/images/链表相交点分类png.png",v="/assets/images/链表相交流程图.svg",m={},g=t(`<h2 id="链表常用的基本代码" tabindex="-1"><a class="header-anchor" href="#链表常用的基本代码" aria-hidden="true">#</a> 链表常用的基本代码：</h2><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> x<span class="token punctuation">;</span>
	Node<span class="token operator">*</span> next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token operator">*</span>list<span class="token punctuation">,</span>listpoint<span class="token punctuation">;</span> 

<span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span>list head<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d\\t&quot;</span><span class="token punctuation">,</span>head<span class="token operator">-&gt;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
		head <span class="token operator">=</span> head<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span>
		
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;\\r\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span>

list <span class="token function">creat_head</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>
	list head <span class="token operator">=</span> <span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>listpoint<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	head<span class="token operator">-&gt;</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>head<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">creat_Node</span><span class="token punctuation">(</span>list head<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>
	list Node <span class="token operator">=</span> <span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>listpoint<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Node<span class="token operator">-&gt;</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>Node<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>head<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span> head <span class="token operator">=</span> head<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	head<span class="token operator">-&gt;</span>next <span class="token operator">=</span> Node<span class="token punctuation">;</span>
	<span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>链表的基本控制只能通过list的头来控制整条链表。</p><p>其实和数组是一样的，数组也是记录了头，但是数组头的记录有可能会多一点。</p><p>（由于C语言值传递的一些现象推测。）</p><h2 id="链表常用工具" tabindex="-1"><a class="header-anchor" href="#链表常用工具" aria-hidden="true">#</a> 链表常用工具</h2><h3 id="链表三指针" tabindex="-1"><a class="header-anchor" href="#链表三指针" aria-hidden="true">#</a> <strong>链表三指针</strong></h3><p>知道三个节点就可以做很多事情了。</p><p>相当于两个数交换，两个数字是真的，需要第三个临时指针进行辅助。</p><div style="text-align:center;"><figure><img src="`+e+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><ul><li>如上图所示，第一个指针先移动，变成下一个指针，</li></ul><p>第二指针变成temp的指针，</p><p>temp指针再移动至下一个指针。</p><ul><li>下面就是最好的写法，把temp放在循环内后建立，以F判断是否为空，</li></ul><p>如果temp在循坏外会导致访问NULL的next是致命的。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>	list midden <span class="token operator">=</span> L<span class="token punctuation">;</span> F <span class="token operator">=</span> midden<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>

	<span class="token keyword">while</span><span class="token punctuation">(</span>F<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		list temp <span class="token operator">=</span> F <span class="token operator">-&gt;</span> next<span class="token punctuation">;</span>    <span class="token comment">//temp不允许再访问链表的下一个NULL的下一个，会报错，也很显而易见就是NULL的next找不到 </span>
		F<span class="token operator">-&gt;</span>next <span class="token operator">=</span> L<span class="token punctuation">;</span>
		L <span class="token operator">=</span> F <span class="token punctuation">;</span>
		F <span class="token operator">=</span> temp <span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>
	<span class="token comment">//</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="假头" tabindex="-1"><a class="header-anchor" href="#假头" aria-hidden="true">#</a> <strong>假头</strong></h3><p>创建一个节点，节点的next指向头，返回的时候返回这个节点的next。</p><p>假头对于排序是非常有用的一个措施。</p><h3 id="快慢指针找中点" tabindex="-1"><a class="header-anchor" href="#快慢指针找中点" aria-hidden="true">#</a> <strong>快慢指针找中点</strong></h3><p>由于链表的特殊结构，找中点是没有这么容易的行为</p><p>通过一个指针跳两步，一个指针跳一步，来实现找到中点的情况，</p><div style="text-align:center;"><figure><img src="`+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><ul><li><p>如上图所示，由于链表数目的偶数和奇数性，取得的中点会有三种情况，在途中已标红。</p></li><li><p>如下列流程图所示，以F指针的下一个作为移动的判断条件，</p></li></ul><p>F的下一个的下一个区分是否LOW指针的运动条件。</p><div style="text-align:center;"><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><ul><li>上图中左边结束的分支的得到的是图中框框围起来的链表，</li></ul><p>右边结束的分支是偏右边的中点</p><p>正下方的结束分支是奇数项的链表结束的方式。</p><h2 id="题目-回文链表" tabindex="-1"><a class="header-anchor" href="#题目-回文链表" aria-hidden="true">#</a> 题目：回文链表</h2><p>判断整个链表是否是回文链表</p><h3 id="装回数组" tabindex="-1"><a class="header-anchor" href="#装回数组" aria-hidden="true">#</a> 装回数组</h3><p>一位内manachar算法是基于数组的，所以可以尝试装回数组再装回去</p><p>时间复杂度O（N），空间复杂度O（N）</p><h3 id="制作一个栈" tabindex="-1"><a class="header-anchor" href="#制作一个栈" aria-hidden="true">#</a> 制作一个栈</h3><p>把链表中的数全部放进去，然后再一一从栈顶取出来，</p><p>和链表开始一一比较。</p><p>时间复杂度O（N），空间复杂度O（N）</p><h3 id="改装链表" tabindex="-1"><a class="header-anchor" href="#改装链表" aria-hidden="true">#</a> 改装链表</h3><p>时间方面是一致的，但是不需要用到额外的空间。</p><div style="text-align:center;"><figure><img src="'+i+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">FL</span><span class="token punctuation">(</span>list head<span class="token punctuation">)</span>  <span class="token comment">//快慢指针的真正的难点就是偶数和奇数的问题   //把链表改了之后，这样干了会出现一个两个相互循环封闭的环 </span>
<span class="token punctuation">{</span>
  <span class="token comment">///boundary</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

	<span class="token comment">//1.快慢指针找中间</span>
	list F <span class="token operator">=</span> head<span class="token punctuation">;</span> list L <span class="token operator">=</span> head<span class="token punctuation">;</span>
	<span class="token keyword">int</span> Len <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

  <span class="token comment">//find the midden</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>F<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>F<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">{</span>
			F <span class="token operator">=</span> F<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
			L <span class="token operator">=</span> L<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
			Len <span class="token operator">=</span> Len <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> 
		<span class="token keyword">else</span> <span class="token punctuation">{</span>   <span class="token comment">//两种情况只出现一种，最好就用if else if </span>
			F <span class="token operator">=</span> F<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
			Len <span class="token operator">=</span> Len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;\\r\\n Len = %d&quot;</span><span class="token punctuation">,</span>Len<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//2.把快指针拖到中间的下一个，记录中间的位置，为第四部做准备开始用n1，n2，n3反转链表。</span>
	list midden <span class="token operator">=</span> L<span class="token punctuation">;</span> F <span class="token operator">=</span> midden<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;\\r\\n midden = %d&quot;</span><span class="token punctuation">,</span>midden<span class="token operator">-&gt;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>F<span class="token punctuation">)</span><span class="token punctuation">{</span>
		list temp <span class="token operator">=</span> F <span class="token operator">-&gt;</span> next<span class="token punctuation">;</span>    <span class="token comment">//temp不允许再访问链表的下一个NULL的下一个，会报错，也很显而易见就是NULL的next找不到 </span>
		F<span class="token operator">-&gt;</span>next <span class="token operator">=</span> L<span class="token punctuation">;</span>
		L <span class="token operator">=</span> F <span class="token punctuation">;</span>
		F <span class="token operator">=</span> temp <span class="token punctuation">;</span> <span class="token punctuation">}</span>

	<span class="token comment">//3.从头和尾巴一一比对链表，走到中点位置都一样就是回文，途中出现错误就返回错误 </span>
	list H <span class="token operator">=</span> head<span class="token punctuation">;</span>list T <span class="token operator">=</span> L<span class="token punctuation">;</span> list Tail <span class="token operator">=</span> L<span class="token punctuation">;</span>
	<span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>H <span class="token operator">!=</span> midden<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>H<span class="token operator">-&gt;</span>x <span class="token operator">!=</span> T<span class="token operator">-&gt;</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span>

		H <span class="token operator">=</span> H<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span> T <span class="token operator">=</span> T<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;\\r\\nflag=%d\\r\\n&quot;</span><span class="token punctuation">,</span>flag<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//4.复原链表，从中间开始再反转链表 </span>
	L <span class="token operator">=</span> Tail<span class="token punctuation">;</span> F <span class="token operator">=</span> Tail<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>F<span class="token operator">!=</span>midden<span class="token punctuation">)</span><span class="token punctuation">{</span>
		list temp <span class="token operator">=</span> F <span class="token operator">-&gt;</span> next<span class="token punctuation">;</span>    <span class="token comment">//从中间改变的时候，temp不允许再访问链表的下一个NULL的下一个，会报错，也很显而易见就是NULL的next找不到 </span>
		F<span class="token operator">-&gt;</span>next <span class="token operator">=</span> L<span class="token punctuation">;</span>
		L <span class="token operator">=</span> F <span class="token punctuation">;</span>
		F <span class="token operator">=</span> temp <span class="token punctuation">;</span> <span class="token punctuation">}</span>
	Tail<span class="token operator">-&gt;</span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="题目-复制含有随机结点的链表" tabindex="-1"><a class="header-anchor" href="#题目-复制含有随机结点的链表" aria-hidden="true">#</a> 题目：复制含有随机结点的链表</h2><p>这里涉及到一个深浅拷贝的问题，应该复制还整条链表出来，</p><p>而不是等于原链表中的节点。</p><div style="text-align:center;"><figure><img src="`+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><ul><li><p>随机链表如上图所示，</p></li><li><p>如果创建新的链表，并且把随机指针等于原链表中的随机指针，如下图：</p></li></ul><div style="text-align:center;"><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>但是我们想要建立的链表是这样的：</p><div style="text-align:center;"><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>因此引发一些问题</p><ul><li><ol><li>随机结点只是数字一样但是其实完全是不一样的结点，</li></ol></li></ul><p>要复制这样的东西和指针有关，都叫深拷贝</p><ul><li><ol start="2"><li>由于随机结点是跳跃式的，所及随机结点的安装应该在所有节点都创立之后，</li></ol></li></ul><p>不然其实你的随机节点都还没有存在，怎么指向他。</p><p>为了解决上面的问题，出现了两种解决方法</p><h3 id="用一个map记录随机节点" tabindex="-1"><a class="header-anchor" href="#用一个map记录随机节点" aria-hidden="true">#</a> 用一个map记录随机节点</h3><p>出现的问题不就是复制链表之后，新的链表找到随机节点时，</p><p>需要旧链表再次遍历找到随机节点，“深拷贝”。</p><p><strong>在复制表的时候，建立一个字典map，记录（这个节点，从这个节点到随机节点的跳步）</strong></p><p>问题解决。</p><h3 id="折磨链表" tabindex="-1"><a class="header-anchor" href="#折磨链表" aria-hidden="true">#</a> 折磨链表</h3><p>最核心的问题就是怎么快速找到随机节点，并且还需要整条链表都存在。</p><p>然后不知道哪个疯子就有办法了：</p><div style="text-align:center;"><figure><img src="'+u+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><ul><li>如上图所示，先把链表每一个节点后面接一个新的节点，数字和前面一样</li></ul><p>然后再把每个新建的节点的随机节点取前节点的随机节点的后一个</p><p>最后拆分链表。</p><p><strong>这是一个coding问题，解决了需要使用map这个额外空间的问题。并且速度还快一点</strong></p><p>因为制作map的时候每个节点有可能遍历多次，但是折磨链表的时候，每个节点最多遍历三次。</p><p>总体来说都是o(N)的时间复杂度。</p><p>复制链表：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>Node<span class="token operator">*</span> <span class="token function">copyList</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
   Node<span class="token operator">*</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>
   <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       Node<span class="token operator">*</span> newNode <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       newNode<span class="token operator">-&gt;</span>data <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>
       newNode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
       newNode<span class="token operator">-&gt;</span>random <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
       cur<span class="token operator">-&gt;</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
       cur <span class="token operator">=</span> newNode<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span>
   <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>连接随机节点</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">connectRandomNodes</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   Node<span class="token operator">*</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>
   <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>random <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           cur<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>random <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>random<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span>
       cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>分开链表</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Node* splitList(Node* head) {
   Node* odd = head-&gt;next;
   Node* cur = head;
   Node* temp = NULL;
   
   while (cur-&gt;next != NULL) {
       temp = cur-&gt;next;
       cur-&gt;next = cur-&gt;next-&gt;next;
       cur = temp;}
       
   return odd;}

\`\`\`c

汇总函数
\`\`\`c
Node* centrol(Node* head) {
    //1.复制链表
    Node* new_head = (Node*)malloc(sizeof(Node));
    new_head = copyList(head);
    //2.连接随机节点
    connectRandomNodes(new_head);
    //3.拆分链表
    new_head = splitList(new_head);

    return new_head;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="寻找链表是否相交" tabindex="-1"><a class="header-anchor" href="#寻找链表是否相交" aria-hidden="true">#</a> 寻找链表是否相交</h2><h3 id="链表的相交点" tabindex="-1"><a class="header-anchor" href="#链表的相交点" aria-hidden="true">#</a> 链表的相交点</h3><div style="text-align:center;"><figure><img src="`+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>由于链表的特性，所以相交的链表的结尾一定是同一个节点，</p><p>只能够得出上面的三种链表情况。</p><h3 id="思维模式" tabindex="-1"><a class="header-anchor" href="#思维模式" aria-hidden="true">#</a> 思维模式</h3><div style="text-align:center;"><figure><img src="'+k+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><h4 id="由此引生出链表是否有环的两种判断方法" tabindex="-1"><a class="header-anchor" href="#由此引生出链表是否有环的两种判断方法" aria-hidden="true">#</a> 由此引生出链表是否有环的两种判断方法：</h4><ul><li>借用哈希表存储节点位置</li></ul><p>遍历链表，将每个节点存入哈希表中，如果存在重复则说明有环。</p><ul><li>快慢指针找环。</li></ul><p>快慢指针，快指针每次走两步，慢指针每次走一步，如果存在环，则两个指针一定会相遇。</p><p>找到环入口节点的方法是当快慢指针相遇之后，把快指针从头一步一步地继续走一遍，</p><p>当快指针和慢指针遇到时，就是环的入口。</p><h4 id="判断相交在环内还是环外" tabindex="-1"><a class="header-anchor" href="#判断相交在环内还是环外" aria-hidden="true">#</a> 判断相交在环内还是环外</h4><p>只需要一个链表的尾结点不断遍历，结束条件为遍历回自己</p><p>当遍历到另一个链表的尾结点时，链表的相交点在环内。</p><h3 id="总体流程图" tabindex="-1"><a class="header-anchor" href="#总体流程图" aria-hidden="true">#</a> 总体流程图</h3><div style="text-align:center;"><figure><img src="'+v+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><h3 id="代码" tabindex="-1"><a class="header-anchor" href="#代码" aria-hidden="true">#</a> 代码：</h3><h3 id="需要注意的问题" tabindex="-1"><a class="header-anchor" href="#需要注意的问题" aria-hidden="true">#</a> 需要注意的问题：</h3><ul><li>1.创建两个相同的结点链表添加的时候，如果像普通的添加链表结点会导致成环</li></ul><p>代码：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//  1.创建节点的时候分两种情况，第一种两个都没有共同点正常添加 第二种用共同点了，直接添加会导致尾部自己成环 </span>
<span class="token keyword">void</span> <span class="token function">creat_Node</span><span class="token punctuation">(</span>list head1<span class="token punctuation">,</span>list head2<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	list Node <span class="token operator">=</span> <span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>listpoint<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Node<span class="token operator">-&gt;</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
	Node<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	
	<span class="token keyword">while</span><span class="token punctuation">(</span>head1<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span> head1 <span class="token operator">=</span> head1<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	head1<span class="token operator">-&gt;</span>next <span class="token operator">=</span> Node<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>head2<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span> head2 <span class="token operator">=</span> head2<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>head2 <span class="token operator">==</span> Node<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token comment">//兼容第二种情况</span>
	head2<span class="token operator">-&gt;</span>next <span class="token operator">=</span> Node<span class="token punctuation">;</span>

	<span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,101),b=[g];function h(x,f){return s(),a("div",null,b)}const L=n(m,[["render",h],["__file","six.html.vue"]]);export{L as default};
