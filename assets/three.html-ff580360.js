import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as a,o as s,c,d as e,w as i,a as t,b as l,e as d}from"./app-e4bb05b4.js";const p="/assets/images/上下文菜单.png",g="/assets/images/qDebug的应用.png",u="/assets/images/复制粘贴等等这些东西的槽.png",h="/assets/images/QT的属性宏.png",_="/assets/images/类的查询方式.jpg",y={},x=d('<h2 id="右键菜单" tabindex="-1"><a class="header-anchor" href="#右键菜单" aria-hidden="true">#</a> 右键菜单</h2><ul><li>&amp;QAction::triggered 是返回这个函数的地址。</li></ul><p>而&amp;QAction::triggered()这个返回的是void。</p><ul><li>上下文菜单</li></ul><p>先用Qmenu排好，放进去</p><p>contextMenuEvent就是右键的菜单，控件的右键菜单有待了解。</p><div style="text-align:center;"><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>160是比较好看的宽度。</p><ul><li>connect的东西</li></ul><p>宏注意复制槽和信号</p><p>&amp;的写法注意&amp;的意思和时候写完之后他说要unresolved。</p><ul><li>qDebug和Action返回的应用</li></ul><div style="text-align:center;"><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>直接接受整个信号的好办法。</p><ul><li>一些复制贴贴的槽只能在下方的界面设置</li></ul><div style="text-align:center;"><figure><img src="'+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><ul><li>快捷键功能</li></ul><table><thead><tr><th>功能</th><th>快捷键</th><th>解释</th></tr></thead><tbody><tr><td>for help</td><td>F1</td><td>寻找帮助文档</td></tr><tr><td>Switch Header/Source Under Curson</td><td>F2</td><td>跟踪光标下的标号，若是变量，可以跟踪到变量声明的地方和函数的地方（切换光标下的函数）</td></tr><tr><td>Switch Between Function Declaration(声明) and Definition Refactor/Rename Symbol Under Curson</td><td>Shift + F2</td><td>切换这个大函数定义和申明</td></tr><tr><td>Find Next</td><td>F3</td><td>寻找下一个 和 Ctrl+F配合的多</td></tr><tr><td>Start Debugging</td><td>F5</td><td>编译当前项目</td></tr><tr><td>Auto-indent Selection</td><td>Ctrl+I</td><td>为选择的文字自动进行缩进</td></tr><tr><td>Toggle Comment Selection</td><td>Ctrl+/</td><td>注释或者消注代码</td></tr><tr><td>Save all</td><td>Ctrl+Shift+R</td><td>文件全部保存</td></tr><tr><td>Bulid</td><td>Ctrl+B</td><td>编译当前项目</td></tr></tbody></table><ul><li>元对象</li></ul><p>QT的元对象编译器(Meta-Object Complier，MOC)是一个预处理器</p><p>在源程序被编译前，先将这些QT特性转换为标准的C++兼容的形式。</p><p>添加Q_OBJECT宏，moc才会对类里的信号与槽的代码进行预处理。</p><ul><li><p>core模块就是QT的核心模块，就是通过这个库来实现的。</p></li><li><p>相关的QObject函数</p></li></ul><table><thead><tr><th style="text-align:center;">函数表</th><th style="text-align:center;">功能</th><th style="text-align:center;">用法</th><th style="text-align:center;">用法描述</th></tr></thead><tbody><tr><td style="text-align:center;">QObeject::meta::Object()</td><td style="text-align:center;">返回元对象，通过一些接口来做出一些判断</td><td style="text-align:center;">QObeject* obj = new QpushButton； obj-&gt;metaObject() -&gt; className()</td><td style="text-align:center;">输出Qpushutton</td></tr><tr><td style="text-align:center;">QObjuce::inherits()</td><td style="text-align:center;">判断一个类是否为这个字符串的子类</td><td style="text-align:center;">QTimer *Timer = new QTimer; Timer-&gt;inherits(&quot;QTimer&quot;)</td><td style="text-align:center;">返回ture</td></tr><tr><td style="text-align:center;">QObject::tr()或QObject::trUtf8()</td><td style="text-align:center;">翻译字符串</td><td style="text-align:center;">-</td><td style="text-align:center;">-</td></tr><tr><td style="text-align:center;">QObject::setProperty()或QObject::Property()用于通过属性名称动态设置和获取属性值</td><td style="text-align:center;">-</td><td style="text-align:center;">-</td><td style="text-align:center;">-</td></tr></tbody></table><p>讲了一个映射的东西，QWidget* mywidget = qobject_cast&lt;QWidget*&gt;(parent)，</p><p>需要是子函数或者说是父函数才能够映射。</p>',26),f=d('<p>所谓的映射就是比较规范的转换需要再是子函数或者父函数的转换。</p><ul><li>属性系统</li></ul><p>QObject中有一个属性系统，Q_PROPERTY宏来定义属性。</p><p>Q_PROPERTY的函数是常函数，常函数就只是在这个函数里面只能够用常变量。</p><ul><li>QT的属性宏</li></ul><div style="text-align:center;"><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>属性宏是为了加强代码的健壮性，并且和property系统进行结合。</p><table><thead><tr><th style="text-align:center;">英语</th><th style="text-align:center;">中文</th></tr></thead><tbody><tr><td style="text-align:center;">notify</td><td style="text-align:center;">通告</td></tr><tr><td style="text-align:center;">revision</td><td style="text-align:center;">修订</td></tr><tr><td style="text-align:center;">designable</td><td style="text-align:center;">可被区分的</td></tr><tr><td style="text-align:center;">scriptable</td><td style="text-align:center;">可被脚本的</td></tr><tr><td style="text-align:center;">stored</td><td style="text-align:center;">可存储的</td></tr></tbody></table><p>类似元组的定义结构。</p><p>因为和本身的property系统连接，所以property和setproperty都可以用来连接这些属性。</p>',10),m=t("p",null,"属性的函数是放在public：上面的。",-1),b=t("ul",null,[t("li",null,"回调函数")],-1),Q=t("p",null,"所谓的回调函数就是使用各种方法来使调用其他的函数。",-1),O={href:"https://zhuanlan.zhihu.com/p/627181746",target:"_blank",rel:"noopener noreferrer"},j=t("ul",null,[t("li",null,"auto的自动遍历")],-1),v=t("p",null,"auto就是自动推导，然后for(auto i : list ) 这样就是C++11新增加的循环写法，更加方便。",-1),q={href:"https://blog.csdn.net/qq_28087491/article/details/108171017",target:"_blank",rel:"noopener noreferrer"},C=t("ul",null,[t("li",null,"explicit关键字")],-1),S=t("p",null,"不允许奇怪隐式调用:",-1),T={href:"https://zhuanlan.zhihu.com/p/52152355",target:"_blank",rel:"noopener noreferrer"},w=t("p",null,"所谓的隐式调用就是左边的变量类型和右边的变量类型不一致，但是却能够运行。",-1),z=t("ul",null,[t("li",null,"消除警告的一种办法")],-1),E={href:"https://lequ7.com/qunused.html",target:"_blank",rel:"noopener noreferrer"},F=d('<p>Q_UNUSED(变量名)宏是用来消除警告的。</p><ul><li>Qstring的相关牛逼用法：</li></ul><p>QString::asprintf(&quot;年龄=%d&quot;,age)；</p><p>QString(&quot;%1%2&quot;.arg(&quot;hello&quot;).arg(&quot;world&quot;));</p><ul><li>类属性的查询方式</li></ul><div style="text-align:center;"><figure><img src="'+_+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><ul><li>获取元对象</li></ul><p>QMetaObject *meta = boy-&gt;metaObject();</p><ul><li>获取元对象的属性</li></ul><p>QMetaProperty *property = meta-&gt;property(index);</p><p>QMetaClassInfo *classInfo = meta-&gt;classInfo(index);</p><p>第一个可以改写，有更多的接口，第二个只能读取。</p><ul><li>QtGlobal</li></ul><p>这个头文件中定义了类型变量，绝对值函数等等等等。</p><p>并且定义了很多的宏</p><p>QT_VERSION 定义版本号 加上_后缀是各种别的东西。</p><p>forreach宏来遍历容器。</p>',17);function N(k,B){const r=a("font"),n=a("ExternalLinkIcon");return s(),c("div",null,[x,e(r,{color:"red"},{default:i(()=>[l("这个parent是一个QObject*类型的指针，所以可以进行类型转换，将parent指针转换为QWidget*类型的指针。")]),_:1}),f,e(r,{color:"red"},{default:i(()=>[l("宏还有一个附加参数")]),_:1}),e(r,{color:"red"},{default:i(()=>[l("Q_CLASSINFO(),定义附加类信息。")]),_:1}),m,b,Q,t("p",null,[t("a",O,[l("回调函数"),e(n)])]),j,v,t("p",null,[t("a",q,[l("auto"),e(n)])]),C,S,t("p",null,[t("a",T,[l("explicit"),e(n)])]),w,z,t("p",null,[t("a",E,[l("乐趣社区"),e(n)])]),F])}const P=o(y,[["render",N],["__file","three.html.vue"]]);export{P as default};
