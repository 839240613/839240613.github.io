import{_ as c}from"./plugin-vue_export-helper-c27b6911.js";import{r as p,o as r,c as o,a as n,b as s,d as e,w as l,e as a}from"./app-e4bb05b4.js";const d={},u=a('<h2 id="printf的用法" tabindex="-1"><a class="header-anchor" href="#printf的用法" aria-hidden="true">#</a> printf的用法</h2><h3 id="占位符" tabindex="-1"><a class="header-anchor" href="#占位符" aria-hidden="true">#</a> 占位符</h3><p>| 符号 | 描述 | | %a | 浮点数 | | %A | 浮点数 | | %c | 字符串 | | %d | 十进制整数 | | %e | 使用科学计数法的浮点数，指数部分的e为小写 | | %E | 使用科学计数法的浮点数，指数部分的E为大写 | | %i | 整数，基本等同于%d | | %f | 小数 | | %g | 6个有效数字的浮点数，整数一旦超过六位，自动转为科学计数法 | | %G | 等同于g只是指数部分的E为大写 | | %% | 输出一个百分号 |</p><h3 id="有一种奇怪的用法" tabindex="-1"><a class="header-anchor" href="#有一种奇怪的用法" aria-hidden="true">#</a> 有一种奇怪的用法</h3><p>printf(%*.*f, width, precision, value);</p><p>printf(&quot;%.5f&quot;,&quot;hello world&quot;);</p><h3 id="不知道的知识点" tabindex="-1"><a class="header-anchor" href="#不知道的知识点" aria-hidden="true">#</a> 不知道的知识点</h3><ul><li><ol><li>for循环的循环条件是一个单独的作用域。</li></ol></li><li><ol start="2"><li>赋值运算时从右到左的，并且赋值表达式是有返回值的，返回值为最后一个赋值的变量的值。</li></ol></li><li><ol start="3"><li>写代码还是多加括号的好。</li></ol></li><li><ol start="4"><li>goto可以跳出嵌套循环或者奇怪的全if结构</li></ol></li></ul><h3 id="转义字符" tabindex="-1"><a class="header-anchor" href="#转义字符" aria-hidden="true">#</a> 转义字符</h3><table><thead><tr><th style="text-align:center;">转义字符</th><th style="text-align:center;">描述</th></tr></thead><tbody><tr><td style="text-align:center;">\\a</td><td style="text-align:center;">警告音</td></tr><tr><td style="text-align:center;">\\b</td><td style="text-align:center;">退格键，删除前一个字符</td></tr><tr><td style="text-align:center;">\\f</td><td style="text-align:center;">换页符</td></tr><tr><td style="text-align:center;">\\n</td><td style="text-align:center;">换行符</td></tr><tr><td style="text-align:center;">\\r</td><td style="text-align:center;">回车键</td></tr><tr><td style="text-align:center;">\\t</td><td style="text-align:center;">水平制表符</td></tr><tr><td style="text-align:center;">\\v</td><td style="text-align:center;">垂直制表符</td></tr><tr><td style="text-align:center;">\\</td><td style="text-align:center;">代表一个反斜杠字符本身</td></tr><tr><td style="text-align:center;">&#39;</td><td style="text-align:center;">代表一个单引号字符本身</td></tr><tr><td style="text-align:center;">&quot;</td><td style="text-align:center;">代表一个双引号字符本身</td></tr><tr><td style="text-align:center;">?</td><td style="text-align:center;">代表一个问号字符本身</td></tr><tr><td style="text-align:center;">\\ddd</td><td style="text-align:center;">八进制字符，ddd为三位八进制数</td></tr><tr><td style="text-align:center;">\\xhh</td><td style="text-align:center;">十六进制字符，hh为两位十六进制数</td></tr><tr><td style="text-align:center;">\\0</td><td style="text-align:center;">代表没有内容</td></tr></tbody></table><h3 id="需要数据类型的长度" tabindex="-1"><a class="header-anchor" href="#需要数据类型的长度" aria-hidden="true">#</a> 需要数据类型的长度</h3><p>在确实需要8个字节的时候，最好就是使用long 16个字节的时候用使用long long 兩个字节的时候使用short 一个字节的时候使用char</p><p>在C语言的头文件库中还存在limits.h这个头文件，里面定义了各种类型的最大值和最小值。</p><p>用宏定义了以下东西。</p><p>SCHAR_MIN,SCHAR_MAX UCHAR_MIN,UCHAR_MAX SHRT_MIN,SHRT_MAX USHRT_MIN,USHRT_MAX INT_MIN,INT_MAX UINT_MIN,UINT_MAX LONG_MIN,LONG_MAX ULONG_MIN,ULONG_MAX LLONG_MIN,LLONG_MAX ULLONG_MIN,ULLONG_MAX</p><h3 id="浮点运算" tabindex="-1"><a class="header-anchor" href="#浮点运算" aria-hidden="true">#</a> 浮点运算</h3><p>小数的运算方法，小数乘上2查看整数的位置，其实就是A*B^(-n)次方中的不断在n为0的地取数，取到一模一样。非常的抽象。</p><p>关于这里有一篇CSDN的好文章</p>',18),h={href:"https://blog.csdn.net/shihengzhen101/article/details/92385277?utm_source=miniapp_weixin",target:"_blank",rel:"noopener noreferrer"},k=a(`<h3 id="字面量后缀" tabindex="-1"><a class="header-anchor" href="#字面量后缀" aria-hidden="true">#</a> 字面量后缀</h3><p>字面量也是有类型的</p><p>前面是:X 0X 0</p><p>后面是:L LU F</p><h3 id="注意溢出问题" tabindex="-1"><a class="header-anchor" href="#注意溢出问题" aria-hidden="true">#</a> 注意溢出问题</h3><p>在</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样的代码会进入无穷无尽的循环，因为溢出</p><h3 id="sizeof运算符" tabindex="-1"><a class="header-anchor" href="#sizeof运算符" aria-hidden="true">#</a> sizeof运算符</h3><p>sizeof(type) 返回type所占的字节数</p><p>在不同的操作系统中，返回值是不一样的，因此，创造了一个类型别名，size_t，来表示sizeof返回的类型。</p><p>这个别名定义在stddef.h中。引入stdio.h头文件时会自动引入。</p><h3 id="类型的自动转换" tabindex="-1"><a class="header-anchor" href="#类型的自动转换" aria-hidden="true">#</a> 类型的自动转换</h3><p>浮点数转换为整数 （不允许） 会导致小数点后没有 整数赋值给浮点数类型 （允许） 窄类型赋值给宽类型 （允许） 宽类型赋值给窄类型 （不允许） 会发生截断，导致错误。</p><h3 id="混合类型转换" tabindex="-1"><a class="header-anchor" href="#混合类型转换" aria-hidden="true">#</a> 混合类型转换</h3><p>int 在进入运算的时候，会自动转换为unsigned int类型，然后再进行运算。</p><p>int为负数的时候转变会导致unsigned int变的很大很大，</p><h3 id="函數" tabindex="-1"><a class="header-anchor" href="#函數" aria-hidden="true">#</a> 函數</h3><p>函數上定义的数据类型就是死的，会被自动转换</p><h3 id="显式转换又叫做强制转换" tabindex="-1"><a class="header-anchor" href="#显式转换又叫做强制转换" aria-hidden="true">#</a> 显式转换又叫做强制转换</h3><h3 id="可移植类型名" tabindex="-1"><a class="header-anchor" href="#可移植类型名" aria-hidden="true">#</a> 可移植类型名</h3><p>(1) 精确宽度类型 int8_t int16_t int32_t int64_t</p><p>等，这些其实都是不同操作系统再嵌套一层，目的是为了兼容</p><p>实际上他是自己在指向存在的数据类型</p><p>如 int8_t 就是char</p><p>(2) 最小宽度类型 int_least8_t int_least16_t int_least32_t int_least64_t</p><p>等，这些指定可以容纳8位有符号整数的最小宽度类型</p><p>(3) 最快的最小宽度类型 int_fast8_t int_fast16_t int_fast32_t int_fast64_t</p><p>可以使整数计算达到最快的类型</p><p>因为计算机位数的不同，32位计算机计算32位的数据会比16位的快，</p><p>因此这样可以弄出最快的类型。</p><p>(4) 最大宽度类型 intmax_t uintmax_t</p><p>这两个类型比long long 还要大</p><p>(5) 可以保存指针的整数类型 intptr_t uintptr_t</p><p>该指针类型存放整数</p><h3 id="指针" tabindex="-1"><a class="header-anchor" href="#指针" aria-hidden="true">#</a> 指针</h3><p>指针变量的初始化</p><p>int* p;</p><p>这样的定义是*p随便取了一个地址</p><p>必须给*p放入一个确定的地址才可以给这个地址进行操作。</p><p>因此最好的定义方法就是</p><p>int* p=NULL;</p><p>NULL表示地址为0的内存空间，是不允许读写的地址。</p><h4 id="指针的加法" tabindex="-1"><a class="header-anchor" href="#指针的加法" aria-hidden="true">#</a> 指针的加法</h4><p>指针的加法可以访问未定义的内存空间</p><p>但是不可以操作。</p><h4 id="指针和指针减法是允许的" tabindex="-1"><a class="header-anchor" href="#指针和指针减法是允许的" aria-hidden="true">#</a> 指针和指针减法是允许的</h4><p>返回类型是ptrdiff_t类型，</p><h3 id="main函数" tabindex="-1"><a class="header-anchor" href="#main函数" aria-hidden="true">#</a> main函数</h3><p>C语言约定，返回值为0表示运行成功，如果返回其他非零整数，那么就表示代码出现了问题。</p><p>函数名 = &amp;函数名 = *函数名 这是一个非常离谱的现象。</p><hr>`,52),v=a('<h3 id="exit" tabindex="-1"><a class="header-anchor" href="#exit" aria-hidden="true">#</a> exit()</h3><p>在头文件&lt;stdlib.h&gt;中</p><p>函数用来终止整个程序的运行</p><p>这个函数是可以设定程序的返回值。</p><p>还有一个atexit(void (*func)(void))函数，用来设定程序的退出函数。</p><p>在整个程序退出之前，会先执行这个函数。</p><p>atexit(void (*func)(void))只是设定了结束前运行这个函数，但是并不会结束这个程序。</p><h3 id="static" tabindex="-1"><a class="header-anchor" href="#static" aria-hidden="true">#</a> static</h3><p>static int j； 这样就默认了 j=0; 并且初始化只有一次。 无论如何都不介意赋值给一个变量。</p><p>还有这样的特别用法 int func(int a[static 3],int n) 只是说明数组的长度至少为3</p><h3 id="const" tabindex="-1"><a class="header-anchor" href="#const" aria-hidden="true">#</a> const</h3><p>int func(const int a[],int n)</p><p>指定函数内部不可以改这个变量。</p><h3 id="可变参数类型" tabindex="-1"><a class="header-anchor" href="#可变参数类型" aria-hidden="true">#</a> 可变参数类型</h3><p>头文件stdarg.h</p><p>va_list list; va_start(list,n); int i; for(i=0;i&lt;n;i++) { int temp=va_arg(list,int); printf(&quot;%d\\n&quot;,temp); }</p><p>va_end(list);</p><p>这个就是可变参数类型的主要用法。</p><h2 id="数组" tabindex="-1"><a class="header-anchor" href="#数组" aria-hidden="true">#</a> 数组</h2><p>int a[10] = {1,2，3，4，5，6，7，8，9，10};</p><p>a = {1,2，3，4，5，6，7，8，9};</p><p>是不允许的，因为变量是不允许改变地址指向的。</p><p>int a[10] = {0}; 这样就是为每个成员都设置为零</p><p>还有你没见过的这种赋值方法</p><p>int a[15] = {[0]=1,[2]=3,[3]=4,[4]=5,[5]=6,[6]=7,[7]=8,[8]=9,[9]=10,[10]=11,[11]=12,[12]=13,[13]=14,[14]=15};</p><h2 id="变长数组" tabindex="-1"><a class="header-anchor" href="#变长数组" aria-hidden="true">#</a> 变长数组</h2><p>数组长度可以使用变量来表示。</p><p>局部变量是保存在栈内的，所以数组长度在没运行的时候是未知。</p><h2 id="数组的地址" tabindex="-1"><a class="header-anchor" href="#数组的地址" aria-hidden="true">#</a> 数组的地址</h2><p>数组第一个成员的地址就是数组的地址。</p><p>即 a = &amp;a[0];</p><p>至于你疑惑的二维数组的问题</p><p>其实是这样的，a[3][4] = {1,2,3,4};</p><p>a[3] 就是一个 A3_i类型的变量</p><p>所有的问题都是对a这个地址，把他定义为什么类型的变量，就会取什么类型的值，做出什么类型的操作。</p>',35),m={href:"https://zhuanlan.zhihu.com/p/174091195?utm_psn=1748313191711764480",target:"_blank",rel:"noopener noreferrer"},b=a(`<h3 id="字符串" tabindex="-1"><a class="header-anchor" href="#字符串" aria-hidden="true">#</a> 字符串</h3><p>因为字符串是记录空格的</p><p>所以在变成第二行的时候需要进行 &quot;sdaddsdaddsd / sadasdaddasd&quot;</p><p>这样的操作。</p><p>不然会提示错误。编译器会认为char找不到结束终端。</p><h4 id="核心问题" tabindex="-1"><a class="header-anchor" href="#核心问题" aria-hidden="true">#</a> 核心问题</h4><p>char a[10]; 与 char* a; 之间的矛盾。</p><p>char* 指向的是常量 而char[] 是一个变量，储存在不同的地方，数据类型也不一样，占的位数也会不一样，这就是最本质的原因。 char就是那块内存地址，不可以更改。</p><p>只是使用的时候，char会被编译器自动转换为&amp;char[0]；</p><h4 id="字符串常常用到的函数" tabindex="-1"><a class="header-anchor" href="#字符串常常用到的函数" aria-hidden="true">#</a> 字符串常常用到的函数</h4><p>头文件为 string.h</p><ul><li>strcpy(char* a,char* b);</li></ul><p>a是堆区的数据，等号右边是全局变量的东西，因此不可以用a[]去改变。</p><p>要改变char* 的问题，需要使用strcpy函数。</p><p>例如：strcpy(a,&quot;sadasdaddasd&quot;);这样就可以改变a的内容，并没有改变指向。</p><p>返回值为第一个参数。</p><p>有一点牛逼的复现写法：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">strcpy</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> dest<span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span> source<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">char</span><span class="token operator">*</span> <span class="token operator">=</span> ptr<span class="token punctuation">;</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token operator">++</span> <span class="token operator">=</span> <span class="token operator">*</span>source<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> ptr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>strlen(char* a);</li></ul><p>返回字符串的长度</p><ul><li>strncpy(char* a,char* b,int n);</li></ul><p>a是目标，b是源，n是长度。</p><p>这个函数使用的时候需要注意，自己添加&#39;\\0&#39;这个字符串</p><p>例子:</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">char</span> s1<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;sadasdaddasd&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> s2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>

<span class="token function">strncpy</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span>s2<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
s1<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">&#39;\\0&#39;</span><span class="token punctuation">;</span>

<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s&quot;</span><span class="token punctuation">,</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//hello</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样的用法才规范</p><ul><li>strcat(char* a,char* b);</li></ul><p>链接字符串</p><ul><li><p>strncat(char* a,char* b,int n); 链接字符串，但是只链接n个</p></li><li><p>strcmp(char* a,char* b);</p></li></ul><p>比较字符串</p><ul><li>strncmp(char* a,char* b,int n);</li></ul><p>比较字符串，但是只比较n个，且是两个字符串的前两个。</p><ul><li>sprintf与snprintf</li></ul><p>比较少用的字符串打印方法</p><h4 id="二维数组的牛逼用法" tabindex="-1"><a class="header-anchor" href="#二维数组的牛逼用法" aria-hidden="true">#</a> 二维数组的牛逼用法</h4><p>char* a[100]; 这样就会比较节省空间的使用。</p>`,36),f={href:"https://zhuanlan.zhihu.com/p/114161428?utm_psn=1748372923050766336",target:"_blank",rel:"noopener noreferrer"},g=a(`<p>上面这个本质是char* 数组不是什么，是一百个字符的头节点罢了。</p><p>在解析这个牛逼写法中我写了以下代码</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span>
	<span class="token punctuation">{</span>
		<span class="token string">&quot;sss&quot;</span><span class="token punctuation">,</span>
		<span class="token string">&quot;ssss&quot;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
		

	
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%p\\r\\n&quot;</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%p\\r\\n&quot;</span><span class="token punctuation">,</span>str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%p\\r\\n&quot;</span><span class="token punctuation">,</span>str<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出为： 000000000062FDE0 000000000040400A 000000000040400E</p><p>也就是说这样也是无法改变&quot;ssss&quot;的，因为这个也存储在静态区中。</p><h4 id="void-指针的作用" tabindex="-1"><a class="header-anchor" href="#void-指针的作用" aria-hidden="true">#</a> void* 指针的作用</h4><p>void* 指针可以随便转化为int*，并且为无类型指针。</p><ul><li>malloc()</li></ul><p>用于分配内存，</p><p>void* malloc(size_t size)</p><p>例子</p><div class="language-C line-numbers-mode" data-ext="C"><pre class="language-C"><code>int* = (int* ) malloc(sizeof(int));

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>free()</li></ul><p>用于释放malloc内存。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>doubel<span class="token operator">*</span> temp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上述代码如果存在于局部函数中，并且temp已经丢失，没有free</p><p>那么就会导致留下多个内存块。</p><ul><li>calloc()</li></ul><p>用于分配内存，并且初始化为0</p><p>void* calloc(size_t num,size_t size);</p><p>等效于 int* p = (int* ) malloc(sizeof(int) * num); memset(int* p,0,sizeof(int) * num);</p><ul><li>realloc()</li></ul><p>用于修改已经分配的内存块的大小， void* realloc(void* block，size_t size);</p><ul><li>restrict说明符</li></ul><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span><span class="token operator">*</span> restrict p<span class="token punctuation">;</span>
p <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>受限指针，该内存不可以有两种访问方式</p><ul><li>memcpy()</li></ul><p>用于内存拷贝</p><div class="language-C line-numbers-mode" data-ext="C"><pre class="language-C"><code>memcpy(void* restrict dest,const void* restrict src,size_t n);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可以取代strcpy()，并且写法更优。</p><ul><li>memmove()</li></ul><p>头文件为string.h</p><p>memmove(void* dest,const void* src,size_t n)</p><p>如果dest和src是有重复的内存空间，就会重构dest</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">char</span> x<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;Home Sweet Home&quot;</span><span class="token punctuation">;</span>

<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s\\n&quot;</span>，（<span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">memmove</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span><span class="token operator">&amp;</span>x<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token operator">-</span> <span class="token function">memcmp</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

比较两个内存地址大小

### <span class="token keyword">struct</span>

所有的结构体的例子都没有在定义结构体类型的时候初始化。

<span class="token operator">-</span> 复制问题<span class="token punctuation">(</span>数组复制<span class="token operator">?</span><span class="token punctuation">)</span>
<span class="token number">1.</span> 比较容易出现问题的一个地方
\`\`\`c
<span class="token keyword">struct</span> <span class="token class-name">cat</span><span class="token punctuation">{</span> <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> age<span class="token punctuation">;</span> <span class="token punctuation">}</span>a<span class="token punctuation">,</span>b<span class="token punctuation">;</span>

<span class="token function">strcpy</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>name<span class="token punctuation">,</span><span class="token string">&quot;kitty&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
a<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

b <span class="token operator">=</span> a<span class="token punctuation">;</span>
b<span class="token punctuation">.</span>name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">&#39;B&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这是允许的。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">cat</span><span class="token punctuation">{</span> <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> age<span class="token punctuation">;</span> <span class="token punctuation">}</span>a<span class="token punctuation">,</span>b<span class="token punctuation">;</span>

a<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;kitty&quot;</span><span class="token punctuation">;</span>

b <span class="token operator">=</span> a<span class="token punctuation">;</span>
b<span class="token punctuation">.</span>name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">&#39;B&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样的东西就是都是指向常量的那个指针，是不允许修改的了。</p><ul><li>牛逼的位字段</li></ul><ol start="2"><li>位字符的使用方法</li></ol><p>struct bit_field{ unsigned int f1:1; unsigned int f2:1; unsigned int f3:1; unsigned int f4:1; unsigned int f5:1; unsigned int f6:1; unsigned int f7:1; unsigned int f8:1; unsigned int f9:1; unsigned int f10:1; unsigned int f11:1; unsigned int f12:1; unsigned int f13:1; }</p><p>只能使用整数类型来命这个名。</p><h3 id="typedef" tabindex="-1"><a class="header-anchor" href="#typedef" aria-hidden="true">#</a> typedef</h3><p>作用： 可以快速修改被typedef使用过的数据类型</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">int</span><span class="token operator">*</span> int_ptr<span class="token punctuation">;</span>
int_ptr p1<span class="token punctuation">,</span>p2<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">double</span> int_ptr<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="union" tabindex="-1"><a class="header-anchor" href="#union" aria-hidden="true">#</a> Union</h3><p>一个意向不到的结构</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">union</span> data_un<span class="token punctuation">{</span>
	<span class="token keyword">int</span> i<span class="token punctuation">;</span>
	<span class="token keyword">float</span> f<span class="token punctuation">;</span>
	<span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

一次只能出来一个值，并且使用的哪个值，就会私用哪个值的指针，非常的离谱。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>好处，节省空间，一段空间，定义了三个属性，占用的长度是内部最长属性的长度。</p><h3 id="enum" tabindex="-1"><a class="header-anchor" href="#enum" aria-hidden="true">#</a> enum</h3><p>有两种用法，第一种是定义，第二种是常量用法</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">enum</span><span class="token punctuation">{</span>
	MON<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>
	TUE<span class="token punctuation">,</span>
	WED<span class="token punctuation">,</span>
	THU<span class="token punctuation">,</span>
	FRI<span class="token punctuation">,</span>
	SAT<span class="token punctuation">,</span>
	SUN<span class="token punctuation">}</span> a <span class="token operator">=</span> MON<span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>a就为1。</p><p>第二种用法：</p><p>enum{ MON=1, TUE, WED, THU, FRI, SAT, SUN }</p><p>这些就都是常量，直接是使用。</p><h2 id="预处理器" tabindex="-1"><a class="header-anchor" href="#预处理器" aria-hidden="true">#</a> 预处理器</h2><p>预处理指令</p><p>带有#符号的都是预编译指令，并且这种指令一般都只有一行。</p><h3 id="define-定义了就不可以变化-不然就会报错。" tabindex="-1"><a class="header-anchor" href="#define-定义了就不可以变化-不然就会报错。" aria-hidden="true">#</a> #define 定义了就不可以变化，不然就会报错。</h3><p>有一个这样的宏错误</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SQUARE</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span> x<span class="token operator">*</span>x</span></span>

<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token function">SQUARE</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">+</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//a是19</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为会原样替换，所以，3+4*3+4，所以a是19。</p><p>因此定义宏最好的办法就是多加括号</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SQUARE</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token function">SQUARE</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">+</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//a是49</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>牛逼的宏可以用来变成函数。不过现在的人很少这样干。</p><h4 id="和" tabindex="-1"><a class="header-anchor" href="#和" aria-hidden="true">#</a> #和##</h4><p>#define SUL(x) #x</p><p>会把x变成文本</p><p>#define SUL(x) i##x</p><p>输出的时候会导致i和参数贴合。</p><h4 id="不定参数的宏" tabindex="-1"><a class="header-anchor" href="#不定参数的宏" aria-hidden="true">#</a> 不定参数的宏</h4><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PRINT</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span>__VA_ARGS__<span class="token punctuation">)</span></span></span>

<span class="token function">PRINT</span><span class="token punctuation">(</span><span class="token string">&quot;hello world\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>多余的参数自动用，隔开</p><h3 id="undef" tabindex="-1"><a class="header-anchor" href="#undef" aria-hidden="true">#</a> #undef</h3><p>取消宏定义</p><h3 id="include" tabindex="-1"><a class="header-anchor" href="#include" aria-hidden="true">#</a> #include &quot;&quot;</h3><p>如果要包含的头文件不在当前目录下，需要指定路径，并且需要使用双引号。</p><p>多次包含同一个文件，只会包含一次。是合法的。</p><h3 id="ifndef的作用仅仅是防止-h文件重新加载" tabindex="-1"><a class="header-anchor" href="#ifndef的作用仅仅是防止-h文件重新加载" aria-hidden="true">#</a> ifndef的作用仅仅是防止.h文件重新加载</h3><p>因为没定义就会定义，所以这是一个非常随便的名字，并没有一定需要这个文件的全部大写。</p><h3 id="预定义宏" tabindex="-1"><a class="header-anchor" href="#预定义宏" aria-hidden="true">#</a> 预定义宏</h3><table><thead><tr><th style="text-align:center;">名称</th><th style="text-align:center;">作用</th></tr></thead><tbody><tr><td style="text-align:center;"><em>DATE</em></td><td style="text-align:center;">编译日期</td></tr><tr><td style="text-align:center;"><em>TIME</em></td><td style="text-align:center;">编译时间</td></tr><tr><td style="text-align:center;"><em>FILE</em></td><td style="text-align:center;">编译文件</td></tr><tr><td style="text-align:center;"><em>LINE</em></td><td style="text-align:center;">当前行号</td></tr><tr><td style="text-align:center;"><em>func</em></td><td style="text-align:center;">当前正在执行的函数名</td></tr><tr><td style="text-align:center;"><em>STDC</em></td><td style="text-align:center;">如果被设为1，表示当前编译器遵循c标准</td></tr><tr><td style="text-align:center;"><em>STDC_HOSTED</em></td><td style="text-align:center;">如果被设为1，表示当前编译器可以提供完成整的标准库；否则被设为0</td></tr><tr><td style="text-align:center;"><em>STDC_VERSION</em></td><td style="text-align:center;">编译所使用的C语言版本，是一个格式为yyyymml的长整数，</td></tr></tbody></table><h3 id="line" tabindex="-1"><a class="header-anchor" href="#line" aria-hidden="true">#</a> line</h3><p>重置下一行并且更换文件名</p><p>#line 300 &quot;newFile&quot;</p><h3 id="error" tabindex="-1"><a class="header-anchor" href="#error" aria-hidden="true">#</a> error</h3><p>#error asdasldjsl</p><p>终止程序，并放出后面的语句</p><h3 id="pragma" tabindex="-1"><a class="header-anchor" href="#pragma" aria-hidden="true">#</a> pragma</h3><p>用来修改编译器属性。</p><h2 id="i-o函数" tabindex="-1"><a class="header-anchor" href="#i-o函数" aria-hidden="true">#</a> I/O函数</h2><p>输入输出函数</p><h3 id="缓存与字节流" tabindex="-1"><a class="header-anchor" href="#缓存与字节流" aria-hidden="true">#</a> 缓存与字节流</h3><p>严格来说，输入输出函数并不是直接与外部设备通讯的，而是通过缓存(buffer)进行间接通信，</p><p>字节流的来源就是，文件不是从硬盘里面读取的，而是文件从硬盘上读取放在内存上，读完了再继续</p><p>这就像水流一样，因此，输入输出函数的输入和输出都叫字节流。</p><h4 id="scnaf函数" tabindex="-1"><a class="header-anchor" href="#scnaf函数" aria-hidden="true">#</a> scnaf函数</h4><p>用于读取用户的键盘输入，程序运行到这个语句的时候，就会停下来，等待用户的键盘输入。用户输入数据，按下回车后，就会存进变量。</p><p>原理是，用户的输入先放入缓存，按下回车键之后，按照占位符对缓存进行解读，</p><p>scanf是会自动匹配类型的，是该类型的才会读到，不是该类型的一概不理,并且保存读取位置到上一次读取的最后面，像水流一样。</p><p>总的来说就是限定格式，并读取相关类型，格式不对读取的东西很大可能性都是错误的。</p><p>%c 可以读取空格</p><p>%s 是一个比较危险的东西，应该%[m]s 这样用，因为会不知道是否超过数组。</p><h5 id="赋值忽略符" tabindex="-1"><a class="header-anchor" href="#赋值忽略符" aria-hidden="true">#</a> 赋值忽略符</h5><p>scanf(&quot;%d-%d-%d&quot;, &amp;year,&amp;month,&amp;day);</p><p>如果用户输入2020-01-01 会正确解读，但是如果输入的是 2020/01/01 就会解析数据失败。</p><p>因此可以使用正则表达式这样用</p><p>scanf(&quot;%d%*c%d%*c%d&quot;, &amp;year,&amp;month,&amp;day);</p><h4 id="sscanf" tabindex="-1"><a class="header-anchor" href="#sscanf" aria-hidden="true">#</a> sscanf</h4><p>在字符串中取数据</p><h4 id="getchar" tabindex="-1"><a class="header-anchor" href="#getchar" aria-hidden="true">#</a> getchar()</h4><p>通过宏来实现的</p><p>获取第一个字符</p><p>用于判断是否为换行符或者省略空格。</p><h4 id="putchar" tabindex="-1"><a class="header-anchor" href="#putchar" aria-hidden="true">#</a> putchar()</h4><p>通过宏来实现的</p><p>输出一个字符到屏幕</p><h4 id="puts" tabindex="-1"><a class="header-anchor" href="#puts" aria-hidden="true">#</a> puts()</h4><p>输出一个字符串到屏幕</p><h4 id="gets" tabindex="-1"><a class="header-anchor" href="#gets" aria-hidden="true">#</a> gets()</h4><p>获取字符串，不过这个获取也没有数组大小的限制。</p><p>建议使用fgets()</p><h2 id="文件操作" tabindex="-1"><a class="header-anchor" href="#文件操作" aria-hidden="true">#</a> 文件操作</h2><h3 id="文件操作的步骤" tabindex="-1"><a class="header-anchor" href="#文件操作的步骤" aria-hidden="true">#</a> 文件操作的步骤</h3><p>创建file*</p><p>open</p><p>get</p><p>关闭文件</p><h3 id="提供三个默认已经打开的文件-他们的文件指针如下" tabindex="-1"><a class="header-anchor" href="#提供三个默认已经打开的文件-他们的文件指针如下" aria-hidden="true">#</a> 提供三个默认已经打开的文件，他们的文件指针如下：</h3><p>在Linux中，</p><ul><li>stdio(标准输入): 默认来源为键盘，文件指针编号为0</li><li>stdout（标准输出）: 默认来源为显示器，文件指针编号为1</li><li>stderr(标准错误): 默认来源为显示器，文件指针标号为2</li></ul><p>所以改变项目的输出和输入途径，就叫做重定向，</p><h4 id="eof" tabindex="-1"><a class="header-anchor" href="#eof" aria-hidden="true">#</a> EOF</h4><p>end of File</p><p>这个是程序在读到文件的最后面的时候，就会返回一个EOF，并不是文件本身有这个东西。EOF的值实际是-1在&lt;stdio.h&gt;中保存。</p><h4 id="freopen" tabindex="-1"><a class="header-anchor" href="#freopen" aria-hidden="true">#</a> freopen</h4><hr><h2 id="变量说明符" tabindex="-1"><a class="header-anchor" href="#变量说明符" aria-hidden="true">#</a> 变量说明符</h2><h3 id="register" tabindex="-1"><a class="header-anchor" href="#register" aria-hidden="true">#</a> register</h3><p>把变量放在寄存器，以最快的速度读取这个数值。</p><p>因为放在寄存器里面没有地址，所以是没有内存地址这一回事儿的。</p><h3 id="volatile" tabindex="-1"><a class="header-anchor" href="#volatile" aria-hidden="true">#</a> volatile</h3><p>和一些多线程有关系，</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> foo <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token keyword">int</span> bar <span class="token operator">=</span> x<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上述两个代码中，可能会出现x放在缓存(寄存器里面),因此用上述的volatile可以强制x读内存的。</p><p>这个标识符的含义就是不允许编译器优化。</p><h3 id="extern" tabindex="-1"><a class="header-anchor" href="#extern" aria-hidden="true">#</a> extern</h3><p>这个申明就是说在这个文件里面不需要给这个变量内存分配，去全局变量那边找这个东西。</p><h3 id="编译策略" tabindex="-1"><a class="header-anchor" href="#编译策略" aria-hidden="true">#</a> 编译策略</h3><p>先所有的文件都进行编译，然后再进行链接，就可以在本文件没有修改的时候，直接使用编译好的文件，别的文件在重新编译，然后链接。</p><p>这样可以缩短编译的时间。</p><h3 id="make" tabindex="-1"><a class="header-anchor" href="#make" aria-hidden="true">#</a> make</h3><p>make牛逼之处就是自己找这个文件的时间戳是否有改变，有改变才重新编译然后链接，所以可以大大提高编译的效率。</p><h2 id="命令行环境" tabindex="-1"><a class="header-anchor" href="#命令行环境" aria-hidden="true">#</a> 命令行环境</h2><p>可以通过命令行给予参数</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s\\n&quot;</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述程序中，argc是(argument count)和argv是(argument vector)的缩写。</p><p>argc是命令行参数的数量，argv是一个数组，保存了所有的命令行输入。</p><p>argv的一个参数是程序名字。</p><p>并且argv的最后一个参数是空指针，遍历的时候可以在这里做文章。</p><p>在命令行中，可以使用echo $?来查看上一个命令的返回值。</p><h3 id="环境变量" tabindex="-1"><a class="header-anchor" href="#环境变量" aria-hidden="true">#</a> 环境变量</h3><p>getenv(&quot;HOME&quot;);</p><h2 id="多字节字符" tabindex="-1"><a class="header-anchor" href="#多字节字符" aria-hidden="true">#</a> 多字节字符</h2><p>Unicode编码包含了100多万个字符</p><p>UTF-8</p><p>UTF-16</p><p>UTF-32</p><p>都是Unicode相关的东西。</p><p>C语言提供了两个宏，表示当前系统支持的编码字节长度</p><p>定义在limits.h中</p><p>MB_LEN_MAX:任意支持地区的最大字节长度，定义在limits.h</p><p>MB_CUR_MAX:当前语言的最大字节长度，</p><p>Unicode码比ASCII码要大很多很多</p><h3 id="字符的表示方法" tabindex="-1"><a class="header-anchor" href="#字符的表示方法" aria-hidden="true">#</a> 字符的表示方法</h3><p>UTF-8:使用1-4个字节表示一个码点。不同的字符占用的字节数不一样。 UTF-16:使用2-4个字节表示一个码点。 UTF-32:使用4个字节表示一个码点。</p><p>\\123: 以八进制表示一个字符，斜杠后面需要三个数字 \\x4D: 以十六进制表示一个字符，斜杠后面需要两个数字 \\u4E2D: 以Unicode编码表示一个字符，斜杠后面需要四个数字，码点事十六进制表示，需要四个字符 \\U0010FFFF: 以Unicode编码表示一个字符，斜杠后面需要六个数字，码点事十六进制表示，需要六个字符</p><p>下面两种写法只有三个符号才可以用。</p><p>为了保证程序执行时，字符能够正确解读，最好将程序环境切换到本地环境</p><p>在locale.h中定义以下的东西。</p><p>setlocale(LC_ALL, &quot;&quot;);</p><p>C语言中支持使用u8前缀指定字符串的编码模式</p><p>char* s = u8&quot;你好&quot;;</p><p>这样的字符串的占字节大小就会上下浮动变化了。</p><h3 id="有一个宽字符的头文件" tabindex="-1"><a class="header-anchor" href="#有一个宽字符的头文件" aria-hidden="true">#</a> 有一个宽字符的头文件</h3><p>wchar_t.h</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token class-name">wchar_t</span>  s<span class="token operator">=</span> L<span class="token char">&#39;牛&#39;</span><span class="token punctuation">;</span>

<span class="token class-name">wchar_t</span><span class="token operator">*</span> str <span class="token operator">=</span> L<span class="token char">&#39;大牛&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用这个类型，在字面量之前必须加上L。</p><h4 id="mblen" tabindex="-1"><a class="header-anchor" href="#mblen" aria-hidden="true">#</a> mblen()</h4><p>存在stdlib.h里面</p><p>返回一个多字节字符占用的字符数</p><h4 id="wctomb" tabindex="-1"><a class="header-anchor" href="#wctomb" aria-hidden="true">#</a> wctomb</h4><p>Wide character to multibyte character</p><p>转换一个宽字节符变成多字节符</p><h4 id="wcstombs" tabindex="-1"><a class="header-anchor" href="#wcstombs" aria-hidden="true">#</a> wcstombs</h4><p>转还能一个宽字节符字符串变成多字节符字符串。</p>`,197);function x(y,_){const t=p("ExternalLinkIcon"),i=p("center");return r(),o("div",null,[u,n("p",null,[n("a",h,[s("浮点运算"),e(t)])]),k,e(i,null,{default:l(()=>[s("以下和函数的构建有很大的关系，但不仅限于函数构建")]),_:1}),v,n("p",null,[n("a",m,[s("跳转"),e(t)])]),b,n("p",null,[n("a",f,[s("解刨这个用法"),e(t)])]),g])}const N=c(d,[["render",x],["__file","one.html.vue"]]);export{N as default};
