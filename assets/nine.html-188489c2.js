import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as e,e as t}from"./app-e4bb05b4.js";const n="/assets/images/前缀树样子.jpg",s="/assets/images/前缀树的样子2.jpg",r="/assets/images/安排会议开始时间.png",d="/assets/images/安排会议按时间长短分.png",l="/assets/images/切金条.jpg",c="/assets/images/成本和利润.jpg",p="/assets/images/栈倒序.jpg",g="/assets/images/栈倒序2.jpg",o="/assets/images/苹果递归进化.jpg",h="/assets/images/苹果递归进化2.jpg",f="/assets/images/背包递归.jpg",u="/assets/images/树形DP.jpg",m={},v=t('<h2 id="前缀树" tabindex="-1"><a class="header-anchor" href="#前缀树" aria-hidden="true">#</a> 前缀树</h2><div style="text-align:center;"><figure><img src="'+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>前缀树的用处在于，查看前缀是啥，然后快速给出答案。</p><div style="text-align:center;"><figure><img src="'+s+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>前缀树的节点有三个参数，</p><ul><li><p>第一个是经过的次数</p></li><li><p>第二个是在这个节点结束的次数</p></li><li><p>第三个是创建下一个节点的节点数组。数组的数量由字符种类决定</p></li></ul><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>struckct TrieNode {
  private：
    int pass; //经过的次数
    int end; //结束的次数
    TrieNode* next[26]; //下一个节点
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="贪心算法" tabindex="-1"><a class="header-anchor" href="#贪心算法" aria-hidden="true">#</a> 贪心算法</h2><p>堆和排序。</p><h3 id="安排会议" tabindex="-1"><a class="header-anchor" href="#安排会议" aria-hidden="true">#</a> 安排会议</h3><ul><li>一、按开始时间找</li></ul><div style="text-align:center;"><figure><img src="`+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>只要有一个会议很长很长，从开始到结尾，就会导致其他的多个会议不能放入，这个是不允许的。</p><ul><li>二、按时间长短分</li></ul><div style="text-align:center;"><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><ul><li>三、因此真正需要按结束时间分，并删除开始时间在已分配会议的结束时间前的会议。排序好就可以了。</li></ul><h3 id="用贪心做一个字典序最小的字符串" tabindex="-1"><a class="header-anchor" href="#用贪心做一个字典序最小的字符串" aria-hidden="true">#</a> 用贪心做一个字典序最小的字符串</h3><p>两个合并的时候判断和着是不是最大的。</p><p>贪心最重要的就是比较策略是能够传递的，比如甲大于乙，乙大于丙</p><p>那么丙绝对就是小于甲的，比较需要做闭环。</p><h3 id="切金块" tabindex="-1"><a class="header-anchor" href="#切金块" aria-hidden="true">#</a> 切金块</h3><div style="text-align:center;"><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>把所有的数字都放进小根堆</p><p>从小根堆里面拿出两个数字</p><p>然后结合，放进小根堆</p><p>重复操作。记住每次结合相加的数。</p><h3 id="成本和利润" tabindex="-1"><a class="header-anchor" href="#成本和利润" aria-hidden="true">#</a> 成本和利润</h3><div style="text-align:center;"><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>先把所有的项目都放进根据成本小根堆</p><p>然后取出最小的成本，一样的话按照利润放大根堆</p><p>重复上述操作，就可以获取最大利润的项目</p><h3 id="一个数据流-取中位数" tabindex="-1"><a class="header-anchor" href="#一个数据流-取中位数" aria-hidden="true">#</a> 一个数据流，取中位数</h3><p>做两个根堆，小的数全部放进大根堆，大的放进小根堆</p><p>如果两个堆的长度大于二，则重新平衡堆。</p><h3 id="n皇后问题" tabindex="-1"><a class="header-anchor" href="#n皇后问题" aria-hidden="true">#</a> N皇后问题</h3><p>一、 斜率的判断</p><p>目前的行，减去皇后的行，等于目前的列减去皇后的列的绝对值如果是一致的话，那么处于皇后的斜线位置。</p><h3 id="汉诺塔" tabindex="-1"><a class="header-anchor" href="#汉诺塔" aria-hidden="true">#</a> 汉诺塔</h3><p>只有中间的那句话在维护底层最小，一次情况好了，整体就会变得好</p><h3 id="打印字符串全序列。" tabindex="-1"><a class="header-anchor" href="#打印字符串全序列。" aria-hidden="true">#</a> 打印字符串全序列。</h3><p>不断的自己和自己换着玩，就像图的深度遍历一样。</p><h3 id="栈倒序" tabindex="-1"><a class="header-anchor" href="#栈倒序" aria-hidden="true">#</a> 栈倒序</h3><p>通过第一次递归，获取最下面的数据，</p><p>必须要再通过一次递归，倒序放入。</p><div style="text-align:center;"><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><div style="text-align:center;"><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><h3 id="苹果递归进阶" tabindex="-1"><a class="header-anchor" href="#苹果递归进阶" aria-hidden="true">#</a> 苹果递归进阶</h3><div style="text-align:center;"><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><div style="text-align:center;"><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><h3 id="背包递归问题" tabindex="-1"><a class="header-anchor" href="#背包递归问题" aria-hidden="true">#</a> 背包递归问题</h3><p>大神们的递归练就，就是要这个和不要这个的最大值。</p><div style="text-align:center;"><figure><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><h3 id="树形dp" tabindex="-1"><a class="header-anchor" href="#树形dp" aria-hidden="true">#</a> 树形DP</h3><p>这里的考量需要问自己，是否能够处理单独左子树和右子树的信息。</p><ul><li>求树节点最大的距离。</li></ul><div style="text-align:center;"><figure><img src="'+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><ul><li><ol><li>边界</li></ol></li><li><ol start="2"><li>递归</li></ol></li><li><ol start="3"><li>解黑盒</li></ol></li></ul>',57),x=[v];function _(b,y){return a(),e("div",null,x)}const N=i(m,[["render",_],["__file","nine.html.vue"]]);export{N as default};
